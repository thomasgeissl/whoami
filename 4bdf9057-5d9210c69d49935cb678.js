/*! For license information please see 4bdf9057-5d9210c69d49935cb678.js.LICENSE.txt */
"use strict";(self.webpackChunkwhoami=self.webpackChunkwhoami||[]).push([[444],{4054:function(e,t,n){n.d(t,{AL:function(){return ze},CD:function(){return he},Dd:function(){return Ot},F9:function(){return Mt},H5:function(){return De},HN:function(){return G},JL:function(){return ot},Jy:function(){return Ze},KI:function(){return nt},M4:function(){return kt},Mn:function(){return At},O7:function(){return _e},Qg:function(){return pt},Qt:function(){return it},TC:function(){return ke},V$:function(){return wt},YQ:function(){return ge},YY:function(){return Ne},at:function(){return be},bn:function(){return Pt},fY:function(){return Tt},gh:function(){return Be},hB:function(){return Vt},ol:function(){return Ye},p$:function(){return xt},rk:function(){return Ie},sy:function(){return qe},tq:function(){return bt},wL:function(){return Dt},xC:function(){return Me},xV:function(){return vt},zo:function(){return Le}});var r=n(3232),i=n(2610),a=n(2403),o=n(2834),s=n(556),l=n(6540),u=n(9955),c=n(9907),f=n(5626),d=n(2109);function h(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!n){if(Array.isArray(e)||(n=function(e,t){if(!e)return;if("string"==typeof e)return v(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return v(e,t)}(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0,i=function(){};return{s:i,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,o=!0,s=!1;return{s:function(){n=n.call(e)},n:function(){var e=n.next();return o=e.done,e},e:function(e){s=!0,a=e},f:function(){try{o||null==n.return||n.return()}finally{if(s)throw a}}}}function v(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function g(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=(0,u.Z)(e);if(t){var i=(0,u.Z)(this).constructor;n=Reflect.construct(r,arguments,i)}else n=r.apply(this,arguments);return(0,l.Z)(this,n)}}var A=0,m=1,p=2,y=3,x="varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = position.xy * 0.5 + 0.5;\r\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\r\n\r\n}\r\n",w=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e;return(0,c.Z)(this,n),(e=t.call(this,{type:"AdaptiveLuminanceMaterial",defines:{MIP_LEVEL_1X1:"0.0"},uniforms:{luminanceBuffer0:new d.Uniform(null),luminanceBuffer1:new d.Uniform(null),minLuminance:new d.Uniform(.01),deltaTime:new d.Uniform(0),tau:new d.Uniform(1)},fragmentShader:"uniform mediump sampler2D luminanceBuffer0;\r\nuniform sampler2D luminanceBuffer1;\r\n\r\nuniform float minLuminance;\r\nuniform float deltaTime;\r\nuniform float tau;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\t// This 1x1 buffer contains the previous luminance.\r\n\tfloat l0 = texture2D(luminanceBuffer0, vUv).r;\r\n\r\n\t// Get the current average scene luminance.\r\n\t#if __VERSION__ < 300\r\n\r\n\t\tfloat l1 = texture2DLodEXT(luminanceBuffer1, vUv, MIP_LEVEL_1X1).r;\r\n\r\n\t#else\r\n\r\n\t\tfloat l1 = textureLod(luminanceBuffer1, vUv, MIP_LEVEL_1X1).r;\r\n\r\n\t#endif\r\n\r\n\tl0 = max(minLuminance, l0);\r\n\tl1 = max(minLuminance, l1);\r\n\r\n\t// Adapt the luminance using Pattanaik's technique.\r\n\tfloat adaptedLum = l0 + (l1 - l0) * (1.0 - exp(-deltaTime * tau));\r\n\r\n\tgl_FragColor.r = adaptedLum;\r\n\r\n}\r\n",vertexShader:x,blending:d.NoBlending,depthWrite:!1,depthTest:!1,extensions:{shaderTextureLOD:!0}})).toneMapped=!1,e}return(0,f.Z)(n)}(d.ShaderMaterial),C="uniform sampler2D inputBuffer;\r\nuniform sampler2D cocBuffer;\r\n\r\nuniform vec2 texelSize;\r\nuniform float scale;\r\n\r\n#if PASS == 1\r\n\r\n\tuniform vec4 kernel64[32];\r\n\r\n#else\r\n\r\n\tuniform vec4 kernel16[8];\r\n\r\n#endif\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\t#ifdef FOREGROUND\r\n\r\n\t\tvec2 CoCNearFar = texture2D(cocBuffer, vUv).rg;\r\n\t\tfloat CoC = CoCNearFar.r * scale;\r\n\r\n\t#else\r\n\r\n\t\tfloat CoC = texture2D(cocBuffer, vUv).g * scale;\r\n\r\n\t#endif\r\n\r\n\tif(CoC == 0.0) {\r\n\r\n\t\t// Skip blurring.\r\n\t\tgl_FragColor = texture2D(inputBuffer, vUv);\r\n\r\n\t} else {\r\n\r\n\t\t#ifdef FOREGROUND\r\n\r\n\t\t\t// Use far CoC to avoid weak blurring around foreground objects.\r\n\t\t\tvec2 step = texelSize * max(CoC, CoCNearFar.g * scale);\r\n\r\n\t\t#else\r\n\r\n\t\t\tvec2 step = texelSize * CoC;\r\n\r\n\t\t#endif\r\n\r\n\t\t#if PASS == 1\r\n\r\n\t\t\tvec4 acc = vec4(0.0);\r\n\r\n\t\t\t// Each vector contains two sampling points (64 in total).\r\n\t\t\tfor(int i = 0; i < 32; ++i) {\r\n\r\n\t\t\t\tvec4 kernel = kernel64[i];\r\n\r\n\t\t\t\tvec2 uv = step * kernel.xy + vUv;\r\n\t\t\t\tacc += texture2D(inputBuffer, uv);\r\n\r\n\t\t\t\tuv = step * kernel.zw + vUv;\r\n\t\t\t\tacc += texture2D(inputBuffer, uv);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl_FragColor = acc / 64.0;\r\n\r\n\t\t#else\r\n\r\n\t\t\tvec4 maxValue = texture2D(inputBuffer, vUv);\r\n\r\n\t\t\t// Each vector contains two sampling points (16 in total).\r\n\t\t\tfor(int i = 0; i < 8; ++i) {\r\n\r\n\t\t\t\tvec4 kernel = kernel16[i];\r\n\r\n\t\t\t\tvec2 uv = step * kernel.xy + vUv;\r\n\t\t\t\tmaxValue = max(texture2D(inputBuffer, uv), maxValue);\r\n\r\n\t\t\t\tuv = step * kernel.zw + vUv;\r\n\t\t\t\tmaxValue = max(texture2D(inputBuffer, uv), maxValue);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl_FragColor = maxValue;\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n}\r\n",D=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return(0,c.Z)(this,n),(e=t.call(this,{type:"BokehMaterial",defines:{PASS:r?"2":"1"},uniforms:{kernel64:new d.Uniform(null),kernel16:new d.Uniform(null),inputBuffer:new d.Uniform(null),cocBuffer:new d.Uniform(null),texelSize:new d.Uniform(new d.Vector2),scale:new d.Uniform(1)},fragmentShader:C,vertexShader:x,blending:d.NoBlending,depthWrite:!1,depthTest:!1})).toneMapped=!1,i&&(e.defines.FOREGROUND="1"),e.generateKernel(),e}return(0,f.Z)(n,[{key:"generateKernel",value:function(){for(var e=new Float32Array(128),t=new Float32Array(32),n=0,r=0,i=0;i<80;++i){var a=2.39996323*i,o=Math.sqrt(i)/Math.sqrt(80),s=o*Math.cos(a),l=o*Math.sin(a);i%5==0?(t[r++]=s,t[r++]=l):(e[n++]=s,e[n++]=l)}for(var u=[],c=[],f=0;f<128;)u.push(new d.Vector4(e[f++],e[f++],e[f++],e[f++]));for(var h=0;h<32;)c.push(new d.Vector4(t[h++],t[h++],t[h++],t[h++]));this.uniforms.kernel64.value=u,this.uniforms.kernel16.value=c}},{key:"setTexelSize",value:function(e,t){this.uniforms.texelSize.value.set(e,t)}}]),n}(d.ShaderMaterial),E=function(e){(0,s.Z)(n,e);var t=g(n);function n(e){var r;return(0,c.Z)(this,n),(r=t.call(this,{type:"CircleOfConfusionMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new d.Uniform(null),focusDistance:new d.Uniform(0),focalLength:new d.Uniform(0),cameraNear:new d.Uniform(.3),cameraFar:new d.Uniform(1e3)},fragmentShader:"#include <common>\r\n#include <packing>\r\n\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\r\n\tuniform highp sampler2D depthBuffer;\r\n\r\n#else\r\n\r\n\tuniform mediump sampler2D depthBuffer;\r\n\r\n#endif\r\n\r\nuniform float focusDistance;\r\nuniform float focalLength;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n\r\nvarying vec2 vUv;\r\n\r\nfloat readDepth(const in vec2 uv) {\r\n\r\n\t#if DEPTH_PACKING == 3201\r\n\r\n\t\treturn unpackRGBAToDepth(texture2D(depthBuffer, uv));\r\n\r\n\t#else\r\n\r\n\t\treturn texture2D(depthBuffer, uv).r;\r\n\r\n\t#endif\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tfloat depth = readDepth(vUv);\r\n\r\n\t#ifdef PERSPECTIVE_CAMERA\r\n\r\n\t\tfloat viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\r\n\t\tfloat linearDepth = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\r\n\r\n\t#else\r\n\r\n\t\tfloat linearDepth = depth;\r\n\r\n\t#endif\r\n\r\n\tfloat signedDistance = linearDepth - focusDistance;\r\n\tfloat magnitude = smoothstep(0.0, focalLength, abs(signedDistance));\r\n\r\n\tgl_FragColor.rg = vec2(\r\n\t\tstep(signedDistance, 0.0) * magnitude,\r\n\t\tstep(0.0, signedDistance) * magnitude\r\n\t);\r\n\r\n}\r\n",vertexShader:x,blending:d.NoBlending,depthWrite:!1,depthTest:!1})).toneMapped=!1,r.adoptCameraSettings(e),r}return(0,f.Z)(n,[{key:"depthPacking",get:function(){return Number(this.defines.DEPTH_PACKING)},set:function(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}},{key:"adoptCameraSettings",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;null!==e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof d.PerspectiveCamera?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}}]),n}(d.ShaderMaterial),B="varying vec2 vUv;\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\n\r\n#if EDGE_DETECTION_MODE != 0\r\n\r\n\tvarying vec2 vUv2;\r\n\tvarying vec2 vUv3;\r\n\tvarying vec2 vUv4;\r\n\tvarying vec2 vUv5;\r\n\r\n#endif\r\n\r\n#if EDGE_DETECTION_MODE == 1\r\n\r\n\t#include <common>\r\n\r\n#endif\r\n\r\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\r\n\r\n\t#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\r\n\t\tuniform highp sampler2D depthBuffer;\r\n\r\n\t#else\r\n\r\n\t\tuniform mediump sampler2D depthBuffer;\r\n\r\n\t#endif\r\n\r\n\tfloat readDepth(const in vec2 uv) {\r\n\r\n\t\t#if DEPTH_PACKING == 3201\r\n\r\n\t\t\treturn unpackRGBAToDepth(texture2D(depthBuffer, uv));\r\n\r\n\t\t#else\r\n\r\n\t\t\treturn texture2D(depthBuffer, uv).r;\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n\tvec3 gatherNeighbors() {\r\n\r\n\t\tfloat p = readDepth(vUv);\r\n\t\tfloat pLeft = readDepth(vUv0);\r\n\t\tfloat pTop = readDepth(vUv1);\r\n\r\n\t\treturn vec3(p, pLeft, pTop);\r\n\r\n\t}\r\n\r\n#elif PREDICATION_MODE == 2\r\n\r\n\tuniform sampler2D predicationBuffer;\r\n\r\n\tvec3 gatherNeighbors() {\r\n\r\n\t\tfloat p = texture2D(predicationBuffer, vUv).r;\r\n\t\tfloat pLeft = texture2D(predicationBuffer, vUv0).r;\r\n\t\tfloat pTop = texture2D(predicationBuffer, vUv1).r;\r\n\r\n\t\treturn vec3(p, pLeft, pTop);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if PREDICATION_MODE != 0\r\n\r\n\tvec2 calculatePredicatedThreshold() {\r\n\r\n\t\tvec3 neighbours = gatherNeighbors();\r\n\t\tvec2 delta = abs(neighbours.xx - neighbours.yz);\r\n\t\tvec2 edges = step(PREDICATION_THRESHOLD, delta);\r\n\r\n\t\treturn PREDICATION_SCALE * EDGE_THRESHOLD * (1.0 - PREDICATION_STRENGTH * edges);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if EDGE_DETECTION_MODE != 0\r\n\r\n\tuniform sampler2D inputBuffer;\r\n\r\n#endif\r\n\r\nvoid main() {\r\n\r\n\t#if EDGE_DETECTION_MODE == 0\r\n\r\n\t\tconst vec2 threshold = vec2(DEPTH_THRESHOLD);\r\n\r\n\t#elif PREDICATION_MODE != 0\r\n\r\n\t\tvec2 threshold = calculatePredicatedThreshold();\r\n\r\n\t#else\r\n\r\n\t\tconst vec2 threshold = vec2(EDGE_THRESHOLD);\r\n\r\n\t#endif\r\n\r\n\t#if EDGE_DETECTION_MODE == 0\r\n\r\n\t\t// Depth-based edge detection.\r\n\r\n\t\tvec3 neighbors = gatherNeighbors();\r\n\t\tvec2 delta = abs(neighbors.xx - vec2(neighbors.y, neighbors.z));\r\n\t\tvec2 edges = step(threshold, delta);\r\n\r\n\t\tif(dot(edges, vec2(1.0)) == 0.0) {\r\n\r\n\t\t\tdiscard;\r\n\r\n\t\t}\r\n\r\n\t\tgl_FragColor = vec4(edges, 0.0, 1.0);\r\n\r\n\t#elif EDGE_DETECTION_MODE == 1\r\n\r\n\t\t// Luma-based edge detection.\r\n\r\n\t\tfloat l = linearToRelativeLuminance(texture2D(inputBuffer, vUv).rgb);\r\n\t\tfloat lLeft = linearToRelativeLuminance(texture2D(inputBuffer, vUv0).rgb);\r\n\t\tfloat lTop  = linearToRelativeLuminance(texture2D(inputBuffer, vUv1).rgb);\r\n\r\n\t\tvec4 delta;\r\n\t\tdelta.xy = abs(l - vec2(lLeft, lTop));\r\n\r\n\t\tvec2 edges = step(threshold, delta.xy);\r\n\r\n\t\tif(dot(edges, vec2(1.0)) == 0.0) {\r\n\r\n\t\t\tdiscard;\r\n\r\n\t\t}\r\n\r\n\t\t// Calculate right and bottom deltas.\r\n\t\tfloat lRight = linearToRelativeLuminance(texture2D(inputBuffer, vUv2).rgb);\r\n\t\tfloat lBottom  = linearToRelativeLuminance(texture2D(inputBuffer, vUv3).rgb);\r\n\t\tdelta.zw = abs(l - vec2(lRight, lBottom));\r\n\r\n\t\t// Calculate the maximum delta in the direct neighborhood.\r\n\t\tvec2 maxDelta = max(delta.xy, delta.zw);\r\n\r\n\t\t// Calculate left-left and top-top deltas.\r\n\t\tfloat lLeftLeft = linearToRelativeLuminance(texture2D(inputBuffer, vUv4).rgb);\r\n\t\tfloat lTopTop = linearToRelativeLuminance(texture2D(inputBuffer, vUv5).rgb);\r\n\t\tdelta.zw = abs(vec2(lLeft, lTop) - vec2(lLeftLeft, lTopTop));\r\n\r\n\t\t// Calculate the final maximum delta.\r\n\t\tmaxDelta = max(maxDelta.xy, delta.zw);\r\n\t\tfloat finalDelta = max(maxDelta.x, maxDelta.y);\r\n\r\n\t\t// Local contrast adaptation.\r\n\t\tedges.xy *= step(finalDelta, LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);\r\n\r\n\t\tgl_FragColor = vec4(edges, 0.0, 1.0);\r\n\r\n\t#elif EDGE_DETECTION_MODE == 2\r\n\r\n\t\t// Chroma-based edge detection.\r\n\r\n\t\tvec4 delta;\r\n\t\tvec3 c = texture2D(inputBuffer, vUv).rgb;\r\n\r\n\t\tvec3 cLeft = texture2D(inputBuffer, vUv0).rgb;\r\n\t\tvec3 t = abs(c - cLeft);\r\n\t\tdelta.x = max(max(t.r, t.g), t.b);\r\n\r\n\t\tvec3 cTop = texture2D(inputBuffer, vUv1).rgb;\r\n\t\tt = abs(c - cTop);\r\n\t\tdelta.y = max(max(t.r, t.g), t.b);\r\n\r\n\t\tvec2 edges = step(threshold, delta.xy);\r\n\r\n\t\tif(dot(edges, vec2(1.0)) == 0.0) {\r\n\r\n\t\t\tdiscard;\r\n\r\n\t\t}\r\n\r\n\t\t// Calculate right and bottom deltas.\r\n\t\tvec3 cRight = texture2D(inputBuffer, vUv2).rgb;\r\n\t\tt = abs(c - cRight);\r\n\t\tdelta.z = max(max(t.r, t.g), t.b);\r\n\r\n\t\tvec3 cBottom = texture2D(inputBuffer, vUv3).rgb;\r\n\t\tt = abs(c - cBottom);\r\n\t\tdelta.w = max(max(t.r, t.g), t.b);\r\n\r\n\t\t// Calculate the maximum delta in the direct neighborhood.\r\n\t\tvec2 maxDelta = max(delta.xy, delta.zw);\r\n\r\n\t\t// Calculate left-left and top-top deltas.\r\n\t\tvec3 cLeftLeft = texture2D(inputBuffer, vUv4).rgb;\r\n\t\tt = abs(c - cLeftLeft);\r\n\t\tdelta.z = max(max(t.r, t.g), t.b);\r\n\r\n\t\tvec3 cTopTop = texture2D(inputBuffer, vUv5).rgb;\r\n\t\tt = abs(c - cTopTop);\r\n\t\tdelta.w = max(max(t.r, t.g), t.b);\r\n\r\n\t\t// Calculate the final maximum delta.\r\n\t\tmaxDelta = max(maxDelta.xy, delta.zw);\r\n\t\tfloat finalDelta = max(maxDelta.x, maxDelta.y);\r\n\r\n\t\t// Local contrast adaptation.\r\n\t\tedges *= step(finalDelta, LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);\r\n\r\n\t\tgl_FragColor = vec4(edges, 0.0, 1.0);\r\n\r\n\t#endif\r\n\r\n}\r\n",T="uniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\n\r\n#if EDGE_DETECTION_MODE != 0\r\n\r\n\tvarying vec2 vUv2;\r\n\tvarying vec2 vUv3;\r\n\tvarying vec2 vUv4;\r\n\tvarying vec2 vUv5;\r\n\r\n#endif\r\n\r\nvoid main() {\r\n\r\n\tvUv = position.xy * 0.5 + 0.5;\r\n\r\n\t// Left and top texel coordinates.\r\n\tvUv0 = vUv + texelSize * vec2(-1.0, 0.0);\r\n\tvUv1 = vUv + texelSize * vec2(0.0, -1.0);\r\n\r\n\t#if EDGE_DETECTION_MODE != 0\r\n\r\n\t\t// Right and bottom texel coordinates.\r\n\t\tvUv2 = vUv + texelSize * vec2(1.0, 0.0);\r\n\t\tvUv3 = vUv + texelSize * vec2(0.0, 1.0);\r\n\r\n\t\t// Left-left and top-top texel coordinates.\r\n\t\tvUv4 = vUv + texelSize * vec2(-2.0, 0.0);\r\n\t\tvUv5 = vUv + texelSize * vec2(0.0, -2.0);\r\n\r\n\t#endif\r\n\r\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\r\n\r\n}\r\n",M=(d.ShaderMaterial,"#include <common>\r\n#include <dithering_pars_fragment>\r\n\r\nuniform sampler2D inputBuffer;\r\n\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\n\r\nvoid main() {\r\n\r\n\t// Sample top left texel.\r\n\tvec4 sum = texture2D(inputBuffer, vUv0);\r\n\r\n\t// Sample top right texel.\r\n\tsum += texture2D(inputBuffer, vUv1);\r\n\r\n\t// Sample bottom right texel.\r\n\tsum += texture2D(inputBuffer, vUv2);\r\n\r\n\t// Sample bottom left texel.\r\n\tsum += texture2D(inputBuffer, vUv3);\r\n\r\n\t// Compute the average.\r\n\tgl_FragColor = sum * 0.25;\r\n\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n"),S="uniform vec2 texelSize;\r\nuniform vec2 halfTexelSize;\r\nuniform float kernel;\r\nuniform float scale;\r\n\r\n/* Packing multiple texture coordinates into one varying and using a swizzle to\r\nextract them in the fragment shader still causes a dependent texture read. */\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\n\r\nvoid main() {\r\n\r\n\tvec2 uv = position.xy * 0.5 + 0.5;\r\n\tvec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\r\n\r\n\tvUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\r\n\tvUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\r\n\tvUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\r\n\tvUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\r\n\r\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\r\n\r\n}\r\n",P=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new d.Vector2;return(0,c.Z)(this,n),(e=t.call(this,{type:"ConvolutionMaterial",uniforms:{inputBuffer:new d.Uniform(null),texelSize:new d.Uniform(new d.Vector2),halfTexelSize:new d.Uniform(new d.Vector2),kernel:new d.Uniform(0),scale:new d.Uniform(1)},fragmentShader:M,vertexShader:S,blending:d.NoBlending,depthWrite:!1,depthTest:!1})).toneMapped=!1,e.setTexelSize(r.x,r.y),e.kernelSize=F.LARGE,e}return(0,f.Z)(n,[{key:"getKernel",value:function(){return I[this.kernelSize]}},{key:"setTexelSize",value:function(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}}]),n}(d.ShaderMaterial),I=[new Float32Array([0,0]),new Float32Array([0,1,1]),new Float32Array([0,1,1,2]),new Float32Array([0,1,2,2,3]),new Float32Array([0,1,2,3,4,4,5]),new Float32Array([0,1,2,3,4,5,7,8,9,10])],F={VERY_SMALL:0,SMALL:1,MEDIUM:2,LARGE:3,VERY_LARGE:4,HUGE:5},b=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e;return(0,c.Z)(this,n),(e=t.call(this,{type:"CopyMaterial",uniforms:{inputBuffer:new d.Uniform(null),opacity:new d.Uniform(1)},fragmentShader:"uniform sampler2D inputBuffer;\r\nuniform float opacity;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(inputBuffer, vUv);\r\n\tgl_FragColor = opacity * texel;\r\n\r\n\t#include <encodings_fragment>\r\n\r\n}\r\n",vertexShader:x,blending:d.NoBlending,depthWrite:!1,depthTest:!1})).toneMapped=!1,e}return(0,f.Z)(n)}(d.ShaderMaterial),R="#include <packing>\r\n#include <clipping_planes_pars_fragment>\r\n\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\r\n\tuniform highp sampler2D depthBuffer;\r\n\r\n#else\r\n\r\n\tuniform mediump sampler2D depthBuffer;\r\n\r\n#endif\r\n\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n\r\nvarying float vViewZ;\r\nvarying vec4 vProjTexCoord;\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\t// Transform into Cartesian coordinate (not mirrored).\r\n\tvec2 projTexCoord = (vProjTexCoord.xy / vProjTexCoord.w) * 0.5 + 0.5;\r\n\tprojTexCoord = clamp(projTexCoord, 0.002, 0.998);\r\n\r\n\tfloat fragCoordZ = unpackRGBAToDepth(texture2D(depthBuffer, projTexCoord));\r\n\r\n\t#ifdef PERSPECTIVE_CAMERA\r\n\r\n\t\tfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n\r\n\t#else\r\n\r\n\t\tfloat viewZ = orthographicDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n\r\n\t#endif\r\n\r\n\tfloat depthTest = (-vViewZ > -viewZ) ? 1.0 : 0.0;\r\n\r\n\tgl_FragColor.rg = vec2(0.0, depthTest);\r\n\r\n}\r\n",k="#include <common>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvarying float vViewZ;\r\nvarying vec4 vProjTexCoord;\r\n\r\nvoid main() {\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\r\n\tvViewZ = mvPosition.z;\r\n\tvProjTexCoord = gl_Position;\r\n\r\n\t#include <clipping_planes_vertex>\r\n\r\n}\r\n",U=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=arguments.length>1?arguments[1]:void 0;return(0,c.Z)(this,n),(e=t.call(this,{type:"DepthComparisonMaterial",uniforms:{depthBuffer:new d.Uniform(r),cameraNear:new d.Uniform(.3),cameraFar:new d.Uniform(1e3)},fragmentShader:R,vertexShader:k,blending:d.NoBlending,depthWrite:!1,depthTest:!1,morphTargets:!0,skinning:!0})).toneMapped=!1,e.adoptCameraSettings(i),e}return(0,f.Z)(n,[{key:"adoptCameraSettings",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;null!==e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof d.PerspectiveCamera?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA)}}]),n}(d.ShaderMaterial),L=(d.ShaderMaterial,function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e;return(0,c.Z)(this,n),(e=t.call(this,{type:"DepthMaskMaterial",defines:{DEPTH_PACKING_0:"0",DEPTH_PACKING_1:"0"},uniforms:{depthBuffer0:new d.Uniform(null),depthBuffer1:new d.Uniform(null),inputBuffer:new d.Uniform(null)},fragmentShader:"#include <common>\r\n#include <packing>\r\n\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\r\n\tuniform highp sampler2D depthBuffer0;\r\n\tuniform highp sampler2D depthBuffer1;\r\n\r\n#else\r\n\r\n\tuniform mediump sampler2D depthBuffer0;\r\n\tuniform mediump sampler2D depthBuffer1;\r\n\r\n#endif\r\n\r\nuniform sampler2D inputBuffer;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\t#if DEPTH_PACKING_0 == 3201\r\n\r\n\t\tfloat d0 = unpackRGBAToDepth(texture2D(depthBuffer0, vUv));\r\n\r\n\t#else\r\n\r\n\t\tfloat d0 = texture2D(depthBuffer0, vUv).r;\r\n\r\n\t#endif\r\n\r\n\t#if DEPTH_PACKING_1 == 3201\r\n\r\n\t\tfloat d1 = unpackRGBAToDepth(texture2D(depthBuffer1, vUv));\r\n\r\n\t#else\r\n\r\n\t\tfloat d1 = texture2D(depthBuffer1, vUv).r;\r\n\r\n\t#endif\r\n\r\n\tif(d0 < d1) {\r\n\r\n\t\tdiscard;\r\n\r\n\t}\r\n\r\n\tgl_FragColor = texture2D(inputBuffer, vUv);\r\n\r\n}\r\n",vertexShader:x,blending:d.NoBlending,depthWrite:!1,depthTest:!1})).toneMapped=!1,e}return(0,f.Z)(n)}(d.ShaderMaterial)),O=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new d.Vector2,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.COLOR;return(0,c.Z)(this,n),(e=t.call(this,{type:"EdgeDetectionMaterial",defines:{LOCAL_CONTRAST_ADAPTATION_FACTOR:"2.0",EDGE_THRESHOLD:"0.1",DEPTH_THRESHOLD:"0.01",PREDICATION_MODE:"0",PREDICATION_THRESHOLD:"0.01",PREDICATION_SCALE:"2.0",PREDICATION_STRENGTH:"1.0",DEPTH_PACKING:"0"},uniforms:{inputBuffer:new d.Uniform(null),depthBuffer:new d.Uniform(null),predicationBuffer:new d.Uniform(null),texelSize:new d.Uniform(r)},fragmentShader:B,vertexShader:T,blending:d.NoBlending,depthWrite:!1,depthTest:!1})).toneMapped=!1,e.setEdgeDetectionMode(i),e}return(0,f.Z)(n,[{key:"depthPacking",get:function(){return Number(this.defines.DEPTH_PACKING)},set:function(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}},{key:"setEdgeDetectionMode",value:function(e){this.defines.EDGE_DETECTION_MODE=e.toFixed(0),this.needsUpdate=!0}},{key:"setLocalContrastAdaptationFactor",value:function(e){this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR=e.toFixed("6"),this.needsUpdate=!0}},{key:"setEdgeDetectionThreshold",value:function(e){this.defines.EDGE_THRESHOLD=e.toFixed("6"),this.defines.DEPTH_THRESHOLD=(.1*e).toFixed("6"),this.needsUpdate=!0}},{key:"setPredicationMode",value:function(e){this.defines.PREDICATION_MODE=e.toFixed(0),this.needsUpdate=!0}},{key:"setPredicationBuffer",value:function(e){this.uniforms.predicationBuffer.value=e}},{key:"setPredicationThreshold",value:function(e){this.defines.PREDICATION_THRESHOLD=e.toFixed("6"),this.needsUpdate=!0}},{key:"setPredicationScale",value:function(e){this.defines.PREDICATION_SCALE=e.toFixed("6"),this.needsUpdate=!0}},{key:"setPredicationStrength",value:function(e){this.defines.PREDICATION_STRENGTH=e.toFixed("6"),this.needsUpdate=!0}}]),n}(d.ShaderMaterial),G={DEPTH:0,LUMA:1,COLOR:2},N=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3?arguments[3]:void 0,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];return(0,c.Z)(this,n),(e=t.call(this,{type:"EffectMaterial",defines:{DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new d.Uniform(null),depthBuffer:new d.Uniform(null),resolution:new d.Uniform(new d.Vector2),texelSize:new d.Uniform(new d.Vector2),cameraNear:new d.Uniform(.3),cameraFar:new d.Uniform(1e3),aspect:new d.Uniform(1),time:new d.Uniform(0)},blending:d.NoBlending,depthWrite:!1,depthTest:!1,dithering:s})).toneMapped=!1,null!==r&&e.setShaderParts(r),null!==i&&e.setDefines(i),null!==a&&e.setUniforms(a),e.adoptCameraSettings(o),e}return(0,f.Z)(n,[{key:"depthPacking",get:function(){return Number(this.defines.DEPTH_PACKING)},set:function(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}},{key:"setShaderParts",value:function(e){return this.fragmentShader="#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n\r\nuniform sampler2D inputBuffer;\r\n\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\r\n\tuniform highp sampler2D depthBuffer;\r\n\r\n#else\r\n\r\n\tuniform mediump sampler2D depthBuffer;\r\n\r\n#endif\r\n\r\nuniform vec2 resolution;\r\nuniform vec2 texelSize;\r\n\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\nuniform float aspect;\r\nuniform float time;\r\n\r\nvarying vec2 vUv;\r\n\r\nfloat readDepth(const in vec2 uv) {\r\n\r\n\t#if DEPTH_PACKING == 3201\r\n\r\n\t\treturn unpackRGBAToDepth(texture2D(depthBuffer, uv));\r\n\r\n\t#else\r\n\r\n\t\treturn texture2D(depthBuffer, uv).r;\r\n\r\n\t#endif\r\n\r\n}\r\n\r\nfloat getViewZ(const in float depth) {\r\n\r\n\t#ifdef PERSPECTIVE_CAMERA\r\n\r\n\t\treturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\r\n\r\n\t#else\r\n\r\n\t\treturn orthographicDepthToViewZ(depth, cameraNear, cameraFar);\r\n\r\n\t#endif\r\n\r\n}\r\n\r\nFRAGMENT_HEAD\r\n\r\nvoid main() {\r\n\r\n\tFRAGMENT_MAIN_UV\r\n\r\n\tvec4 color0 = texture2D(inputBuffer, UV);\r\n\tvec4 color1 = vec4(0.0);\r\n\r\n\tFRAGMENT_MAIN_IMAGE\r\n\r\n\tgl_FragColor = color0;\r\n\r\n\t#ifdef ENCODE_OUTPUT\r\n\r\n\t\t#include <encodings_fragment>\r\n\r\n\t#endif\r\n\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n".replace(H.FRAGMENT_HEAD,e.get(H.FRAGMENT_HEAD)).replace(H.FRAGMENT_MAIN_UV,e.get(H.FRAGMENT_MAIN_UV)).replace(H.FRAGMENT_MAIN_IMAGE,e.get(H.FRAGMENT_MAIN_IMAGE)),this.vertexShader="uniform vec2 resolution;\r\nuniform vec2 texelSize;\r\n\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\nuniform float aspect;\r\nuniform float time;\r\n\r\nvarying vec2 vUv;\r\n\r\nVERTEX_HEAD\r\n\r\nvoid main() {\r\n\r\n\tvUv = position.xy * 0.5 + 0.5;\r\n\r\n\tVERTEX_MAIN_SUPPORT\r\n\r\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\r\n\r\n}\r\n".replace(H.VERTEX_HEAD,e.get(H.VERTEX_HEAD)).replace(H.VERTEX_MAIN_SUPPORT,e.get(H.VERTEX_MAIN_SUPPORT)),this.needsUpdate=!0,this}},{key:"setDefines",value:function(e){var t,n=h(e.entries());try{for(n.s();!(t=n.n()).done;){var r=t.value;this.defines[r[0]]=r[1]}}catch(i){n.e(i)}finally{n.f()}return this.needsUpdate=!0,this}},{key:"setUniforms",value:function(e){var t,n=h(e.entries());try{for(n.s();!(t=n.n()).done;){var r=t.value;this.uniforms[r[0]]=r[1]}}catch(i){n.e(i)}finally{n.f()}return this}},{key:"adoptCameraSettings",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;null!==e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof d.PerspectiveCamera?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}},{key:"setSize",value:function(e,t){var n=Math.max(e,1),r=Math.max(t,1);this.uniforms.resolution.value.set(n,r),this.uniforms.texelSize.value.set(1/n,1/r),this.uniforms.aspect.value=n/r}}]),n}(d.ShaderMaterial),H={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},z=function(e){(0,s.Z)(n,e);var t=g(n);function n(e){var r;return(0,c.Z)(this,n),(r=t.call(this,{type:"GodRaysMaterial",defines:{SAMPLES_INT:"60",SAMPLES_FLOAT:"60.0"},uniforms:{inputBuffer:new d.Uniform(null),lightPosition:new d.Uniform(e),density:new d.Uniform(1),decay:new d.Uniform(1),weight:new d.Uniform(1),exposure:new d.Uniform(1),clampMax:new d.Uniform(1)},fragmentShader:"#include <common>\r\n#include <dithering_pars_fragment>\r\n\r\nuniform sampler2D inputBuffer;\r\nuniform vec2 lightPosition;\r\nuniform float exposure;\r\nuniform float decay;\r\nuniform float density;\r\nuniform float weight;\r\nuniform float clampMax;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec2 coord = vUv;\r\n\r\n\t// Calculate the vector from this pixel to the light position in screen space.\r\n\tvec2 delta = lightPosition - coord;\r\n\tdelta *= 1.0 / SAMPLES_FLOAT * density;\r\n\r\n\t// A decreasing illumination factor.\r\n\tfloat illuminationDecay = 1.0;\r\n\tvec4 color = vec4(0.0);\r\n\r\n\t/* Estimate the probability of occlusion at each pixel by summing samples\r\n\talong a ray to the light position. */\r\n\tfor(int i = 0; i < SAMPLES_INT; ++i) {\r\n\r\n\t\tcoord += delta;\r\n\t\tvec4 texel = texture2D(inputBuffer, coord);\r\n\r\n\t\t// Apply the sample attenuation scale/decay factors.\r\n\t\ttexel *= illuminationDecay * weight;\r\n\t\tcolor += texel;\r\n\r\n\t\t// Update the exponential decay factor.\r\n\t\tilluminationDecay *= decay;\r\n\r\n\t}\r\n\r\n\tgl_FragColor = clamp(color * exposure, 0.0, clampMax);\r\n\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n",vertexShader:x,blending:d.NoBlending,depthWrite:!1,depthTest:!1})).toneMapped=!1,r}return(0,f.Z)(n,[{key:"samples",get:function(){return Number(this.defines.SAMPLES_INT)},set:function(e){var t=Math.floor(e);this.defines.SAMPLES_INT=t.toFixed(0),this.defines.SAMPLES_FLOAT=t.toFixed(1),this.needsUpdate=!0}}]),n}(d.ShaderMaterial),Q="#include <common>\r\n\r\nuniform sampler2D inputBuffer;\r\n\r\n#ifdef RANGE\r\n\r\n\tuniform vec2 range;\r\n\r\n#elif defined(THRESHOLD)\r\n\r\n\tuniform float threshold;\r\n\tuniform float smoothing;\r\n\r\n#endif\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(inputBuffer, vUv);\r\n\tfloat l = linearToRelativeLuminance(texel.rgb);\r\n\r\n\t#ifdef RANGE\r\n\r\n\t\t// Apply a luminance range mask.\r\n\t\tfloat low = step(range.x, l);\r\n\t\tfloat high = step(l, range.y);\r\n\r\n\t\tl *= low * high;\r\n\r\n\t#elif defined(THRESHOLD)\r\n\r\n\t\tl = smoothstep(threshold, threshold + smoothing, l);\r\n\r\n\t#endif\r\n\r\n\t#ifdef COLOR\r\n\r\n\t\tgl_FragColor = vec4(texel.rgb * l, l);\r\n\r\n\t#else\r\n\r\n\t\tgl_FragColor = vec4(l);\r\n\r\n\t#endif\r\n\r\n}\r\n",Z=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;(0,c.Z)(this,n);var a=null!==i;return(e=t.call(this,{type:"LuminanceMaterial",uniforms:{inputBuffer:new d.Uniform(null),threshold:new d.Uniform(0),smoothing:new d.Uniform(1),range:new d.Uniform(a?i:new d.Vector2)},fragmentShader:Q,vertexShader:x,blending:d.NoBlending,depthWrite:!1,depthTest:!1})).toneMapped=!1,e.colorOutput=r,e.useThreshold=!0,e.useRange=a,e}return(0,f.Z)(n,[{key:"threshold",get:function(){return this.uniforms.threshold.value},set:function(e){this.uniforms.threshold.value=e}},{key:"smoothing",get:function(){return this.uniforms.smoothing.value},set:function(e){this.uniforms.smoothing.value=e}},{key:"useThreshold",get:function(){return void 0!==this.defines.THRESHOLD},set:function(e){e?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.needsUpdate=!0}},{key:"colorOutput",get:function(){return void 0!==this.defines.COLOR},set:function(e){e?this.defines.COLOR="1":delete this.defines.COLOR,this.needsUpdate=!0}},{key:"setColorOutputEnabled",value:function(e){this.colorOutput=e}},{key:"useRange",get:function(){return void 0!==this.defines.RANGE},set:function(e){e?this.defines.RANGE="1":delete this.defines.RANGE,this.needsUpdate=!0}},{key:"luminanceRange",get:function(){return this.useRange},set:function(e){this.useRange=e}},{key:"setLuminanceRangeEnabled",value:function(e){this.useRange=e}}]),n}(d.ShaderMaterial),V="uniform sampler2D maskTexture;\r\nuniform sampler2D inputBuffer;\r\n\r\n#if MASK_FUNCTION != 0\r\n\r\n\tuniform float strength;\r\n\r\n#endif\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\t#if COLOR_CHANNEL == 0\r\n\r\n\t\tfloat mask = texture2D(maskTexture, vUv).r;\r\n\r\n\t#elif COLOR_CHANNEL == 1\r\n\r\n\t\tfloat mask = texture2D(maskTexture, vUv).g;\r\n\r\n\t#elif COLOR_CHANNEL == 2\r\n\r\n\t\tfloat mask = texture2D(maskTexture, vUv).b;\r\n\r\n\t#else\r\n\r\n\t\tfloat mask = texture2D(maskTexture, vUv).a;\r\n\r\n\t#endif\r\n\r\n\t#if MASK_FUNCTION == 0\r\n\r\n\t\t#ifdef INVERTED\r\n\r\n\t\t\tif(mask > 0.0) {\r\n\r\n\t\t\t\tdiscard;\r\n\r\n\t\t\t}\r\n\r\n\t\t#else\r\n\r\n\t\t\tif(mask == 0.0) {\r\n\r\n\t\t\t\tdiscard;\r\n\r\n\t\t\t}\r\n\r\n\t\t#endif\r\n\r\n\t#else\r\n\r\n\t\tmask = clamp(mask * strength, 0.0, 1.0);\r\n\r\n\t\t#ifdef INVERTED\r\n\r\n\t\t\tmask = (1.0 - mask);\r\n\r\n\t\t#endif\r\n\r\n\t\t#if MASK_FUNCTION == 1\r\n\r\n\t\t\tgl_FragColor = mask * texture2D(inputBuffer, vUv);\r\n\r\n\t\t#else\r\n\r\n\t\t\tgl_FragColor = vec4(mask * texture2D(inputBuffer, vUv).rgb, mask);\r\n\r\n\t\t#endif\r\n\r\n\t#endif\r\n\r\n}\r\n",Y=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return(0,c.Z)(this,n),(e=t.call(this,{type:"MaskMaterial",uniforms:{maskTexture:new d.Uniform(r),inputBuffer:new d.Uniform(null),strength:new d.Uniform(1)},fragmentShader:V,vertexShader:x,blending:d.NoBlending,depthWrite:!1,depthTest:!1})).toneMapped=!1,e.colorChannel=A,e.maskFunction=X.DISCARD,e}return(0,f.Z)(n,[{key:"maskTexture",set:function(e){this.uniforms.maskTexture.value=e}},{key:"colorChannel",set:function(e){this.defines.COLOR_CHANNEL=e.toFixed(0),this.needsUpdate=!0}},{key:"maskFunction",set:function(e){this.defines.MASK_FUNCTION=e.toFixed(0),this.needsUpdate=!0}},{key:"inverted",get:function(){return void 0!==this.defines.INVERTED},set:function(e){this.inverted&&!e?delete this.defines.INVERTED:e&&(this.defines.INVERTED="1"),this.needsUpdate=!0}},{key:"strength",get:function(){return this.uniforms.strength.value},set:function(e){this.uniforms.strength.value=e}}]),n}(d.ShaderMaterial),X={DISCARD:0,MULTIPLY:1,MULTIPLY_RGB_SET_ALPHA:2},W="uniform sampler2D inputBuffer;\r\n\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\n\r\nvoid main() {\r\n\r\n\tvec2 c0 = texture2D(inputBuffer, vUv0).rg;\r\n\tvec2 c1 = texture2D(inputBuffer, vUv1).rg;\r\n\tvec2 c2 = texture2D(inputBuffer, vUv2).rg;\r\n\tvec2 c3 = texture2D(inputBuffer, vUv3).rg;\r\n\r\n\tfloat d0 = (c0.x - c1.x) * 0.5;\r\n\tfloat d1 = (c2.x - c3.x) * 0.5;\r\n\tfloat d = length(vec2(d0, d1));\r\n\r\n\tfloat a0 = min(c0.y, c1.y);\r\n\tfloat a1 = min(c2.y, c3.y);\r\n\tfloat visibilityFactor = min(a0, a1);\r\n\r\n\tgl_FragColor.rg = (1.0 - visibilityFactor > 0.001) ? vec2(d, 0.0) : vec2(0.0, d);\r\n\r\n}\r\n",K="uniform vec2 texelSize;\r\n\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\n\r\nvoid main() {\r\n\r\n\tvec2 uv = position.xy * 0.5 + 0.5;\r\n\r\n\tvUv0 = vec2(uv.x + texelSize.x, uv.y);\r\n\tvUv1 = vec2(uv.x - texelSize.x, uv.y);\r\n\tvUv2 = vec2(uv.x, uv.y + texelSize.y);\r\n\tvUv3 = vec2(uv.x, uv.y - texelSize.y);\r\n\r\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\r\n\r\n}\r\n",j=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new d.Vector2;return(0,c.Z)(this,n),(e=t.call(this,{type:"OutlineMaterial",uniforms:{inputBuffer:new d.Uniform(null),texelSize:new d.Uniform(new d.Vector2)},fragmentShader:W,vertexShader:K,blending:d.NoBlending,depthWrite:!1,depthTest:!1})).toneMapped=!1,e.setTexelSize(r.x,r.y),e.uniforms.maskTexture=e.uniforms.inputBuffer,e}return(0,f.Z)(n,[{key:"setTexelSize",value:function(e,t){this.uniforms.texelSize.value.set(e,t)}}]),n}(d.ShaderMaterial),J="#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\r\n\r\n#if __VERSION__ < 300\r\n\r\n\t#define round(v) floor(v + 0.5)\r\n\r\n#endif\r\n\r\nuniform sampler2D inputBuffer;\r\nuniform sampler2D areaTexture;\r\nuniform sampler2D searchTexture;\r\n\r\nuniform vec2 texelSize;\r\nuniform vec2 resolution;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\nvarying vec2 vPixCoord;\r\n\r\n\r\n/**\r\n * Moves values to a target vector based on a given conditional vector.\r\n */\r\n\r\nvoid movec(const in bvec2 c, inout vec2 variable, const in vec2 value) {\r\n\r\n\tif(c.x) { variable.x = value.x; }\r\n\tif(c.y) { variable.y = value.y; }\r\n\r\n}\r\n\r\nvoid movec(const in bvec4 c, inout vec4 variable, const in vec4 value) {\r\n\r\n\tmovec(c.xy, variable.xy, value.xy);\r\n\tmovec(c.zw, variable.zw, value.zw);\r\n\r\n}\r\n\r\n/**\r\n * Allows to decode two binary values from a bilinear-filtered access.\r\n *\r\n * Bilinear access for fetching 'e' have a 0.25 offset, and we are interested\r\n * in the R and G edges:\r\n *\r\n * +---G---+-------+\r\n * |   x o R   x   |\r\n * +-------+-------+\r\n *\r\n * Then, if one of these edge is enabled:\r\n *  Red: (0.75 * X + 0.25 * 1) => 0.25 or 1.0\r\n *  Green: (0.75 * 1 + 0.25 * X) => 0.75 or 1.0\r\n *\r\n * This function will unpack the values (mad + mul + round):\r\n * wolframalpha.com: round(x * abs(5 * x - 5 * 0.75)) plot 0 to 1\r\n */\r\n\r\nvec2 decodeDiagBilinearAccess(in vec2 e) {\r\n\r\n\te.r = e.r * abs(5.0 * e.r - 5.0 * 0.75);\r\n\r\n\treturn round(e);\r\n\r\n}\r\n\r\nvec4 decodeDiagBilinearAccess(in vec4 e) {\r\n\r\n\te.rb = e.rb * abs(5.0 * e.rb - 5.0 * 0.75);\r\n\r\n\treturn round(e);\r\n\r\n}\r\n\r\n/**\r\n * Diagonal pattern searches.\r\n */\r\n\r\nvec2 searchDiag1(const in vec2 texCoord, const in vec2 dir, out vec2 e) {\r\n\r\n\tvec4 coord = vec4(texCoord, -1.0, 1.0);\r\n\tvec3 t = vec3(texelSize, 1.0);\r\n\r\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\tif(!(coord.z < float(MAX_SEARCH_STEPS_DIAG_INT - 1) && coord.w > 0.9)) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tcoord.xyz = t * vec3(dir, 1.0) + coord.xyz;\r\n\t\te = texture2D(inputBuffer, coord.xy).rg;\r\n\t\tcoord.w = dot(e, vec2(0.5));\r\n\r\n\t}\r\n\r\n\treturn coord.zw;\r\n\r\n}\r\n\r\nvec2 searchDiag2(const in vec2 texCoord, const in vec2 dir, out vec2 e) {\r\n\r\n\tvec4 coord = vec4(texCoord, -1.0, 1.0);\r\n\tcoord.x += 0.25 * texelSize.x; // See @SearchDiag2Optimization\r\n\tvec3 t = vec3(texelSize, 1.0);\r\n\r\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\tif(!(coord.z < float(MAX_SEARCH_STEPS_DIAG_INT - 1) && coord.w > 0.9)) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tcoord.xyz = t * vec3(dir, 1.0) + coord.xyz;\r\n\r\n\t\t// @SearchDiag2Optimization\r\n\t\t// Fetch both edges at once using bilinear filtering.\r\n\t\te = texture2D(inputBuffer, coord.xy).rg;\r\n\t\te = decodeDiagBilinearAccess(e);\r\n\r\n\t\t// Non-optimized version:\r\n\t\t// e.g = texture2D(inputBuffer, coord.xy).g;\r\n\t\t// e.r = SMAASampleLevelZeroOffset(inputBuffer, coord.xy, vec2(1, 0)).r;\r\n\r\n\t\tcoord.w = dot(e, vec2(0.5));\r\n\r\n\t}\r\n\r\n\treturn coord.zw;\r\n\r\n}\r\n\r\n/**\r\n * Calculates the area corresponding to a certain diagonal distance and crossing\r\n * edges 'e'.\r\n */\r\n\r\nvec2 areaDiag(const in vec2 dist, const in vec2 e, const in float offset) {\r\n\r\n\tvec2 texCoord = vec2(AREATEX_MAX_DISTANCE_DIAG, AREATEX_MAX_DISTANCE_DIAG) * e + dist;\r\n\r\n\t// Apply a scale and bias for mapping to texel space.\r\n\ttexCoord = AREATEX_PIXEL_SIZE * texCoord + 0.5 * AREATEX_PIXEL_SIZE;\r\n\r\n\t// Diagonal areas are on the second half of the texture.\r\n\ttexCoord.x += 0.5;\r\n\r\n\t// Move to the proper place, according to the subpixel offset.\r\n\ttexCoord.y += AREATEX_SUBTEX_SIZE * offset;\r\n\r\n\treturn texture2D(areaTexture, texCoord).rg;\r\n\r\n}\r\n\r\n/**\r\n * Searches for diagonal patterns and returns the corresponding weights.\r\n */\r\n\r\nvec2 calculateDiagWeights(const in vec2 texCoord, const in vec2 e, const in vec4 subsampleIndices) {\r\n\r\n\tvec2 weights = vec2(0.0);\r\n\r\n\t// Search for the line ends.\r\n\tvec4 d;\r\n\tvec2 end;\r\n\r\n\tif(e.r > 0.0) {\r\n\r\n\t\td.xz = searchDiag1(texCoord, vec2(-1.0,  1.0), end);\r\n\t\td.x += float(end.y > 0.9);\r\n\r\n\t} else {\r\n\r\n\t\td.xz = vec2(0.0);\r\n\r\n\t}\r\n\r\n\td.yw = searchDiag1(texCoord, vec2(1.0, -1.0), end);\r\n\r\n\tif(d.x + d.y > 2.0) { // d.x + d.y + 1 > 3\r\n\r\n\t\t// Fetch the crossing edges.\r\n\t\tvec4 coords = vec4(-d.x + 0.25, d.x, d.y, -d.y - 0.25) * texelSize.xyxy + texCoord.xyxy;\r\n\t\tvec4 c;\r\n\t\tc.xy = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(-1, 0)).rg;\r\n\t\tc.zw = sampleLevelZeroOffset(inputBuffer, coords.zw, vec2(1, 0)).rg;\r\n\t\tc.yxwz = decodeDiagBilinearAccess(c.xyzw);\r\n\r\n\t\t// Non-optimized version:\r\n\t\t// vec4 coords = vec4(-d.x, d.x, d.y, -d.y) * texelSize.xyxy + texCoord.xyxy;\r\n\t\t// vec4 c;\r\n\t\t// c.x = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(-1, 0)).g;\r\n\t\t// c.y = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(0, 0)).r;\r\n\t\t// c.z = sampleLevelZeroOffset(inputBuffer, coords.zw, vec2(1, 0)).g;\r\n\t\t// c.w = sampleLevelZeroOffset(inputBuffer, coords.zw, vec2(1, -1)).r;\r\n\r\n\t\t// Merge crossing edges at each side into a single value.\r\n\t\tvec2 cc = vec2(2.0) * c.xz + c.yw;\r\n\r\n\t\t// Remove the crossing edge if no end of the line could be found.\r\n\t\tmovec(bvec2(step(0.9, d.zw)), cc, vec2(0.0));\r\n\r\n\t\t// Fetch the areas for this line.\r\n\t\tweights += areaDiag(d.xy, cc, subsampleIndices.z);\r\n\r\n\t}\r\n\r\n\t// Search for the line ends.\r\n\td.xz = searchDiag2(texCoord, vec2(-1.0, -1.0), end);\r\n\r\n\tif(sampleLevelZeroOffset(inputBuffer, texCoord, vec2(1, 0)).r > 0.0) {\r\n\r\n\t\td.yw = searchDiag2(texCoord, vec2(1.0), end);\r\n\t\td.y += float(end.y > 0.9);\r\n\r\n\t} else {\r\n\r\n\t\td.yw = vec2(0.0);\r\n\r\n\t}\r\n\r\n\tif(d.x + d.y > 2.0) { // d.x + d.y + 1 > 3\r\n\r\n\t\t// Fetch the crossing edges.\r\n\t\tvec4 coords = vec4(-d.x, -d.x, d.y, d.y) * texelSize.xyxy + texCoord.xyxy;\r\n\t\tvec4 c;\r\n\t\tc.x = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(-1, 0)).g;\r\n\t\tc.y = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(0, -1)).r;\r\n\t\tc.zw = sampleLevelZeroOffset(inputBuffer, coords.zw, vec2(1, 0)).gr;\r\n\t\tvec2 cc = vec2(2.0) * c.xz + c.yw;\r\n\r\n\t\t// Remove the crossing edge if no end of the line could be found.\r\n\t\tmovec(bvec2(step(0.9, d.zw)), cc, vec2(0.0));\r\n\r\n\t\t// Fetch the areas for this line.\r\n\t\tweights += areaDiag(d.xy, cc, subsampleIndices.w).gr;\r\n\r\n\t}\r\n\r\n\treturn weights;\r\n\r\n}\r\n\r\n/**\r\n * Determines how much length should be added in the last step of the searches.\r\n *\r\n * Takes the bilinearly interpolated edge (see @PSEUDO_GATHER4), and adds 0, 1\r\n * or 2 depending on which edges and crossing edges are active.\r\n */\r\n\r\nfloat searchLength(const in vec2 e, const in float offset) {\r\n\r\n\t/* The texture is flipped vertically, with left and right cases taking half\r\n\tof the space horizontally. */\r\n\tvec2 scale = SEARCHTEX_SIZE * vec2(0.5, -1.0);\r\n\tvec2 bias = SEARCHTEX_SIZE * vec2(offset, 1.0);\r\n\r\n\t// Scale and bias to access texel centers.\r\n\tscale += vec2(-1.0, 1.0);\r\n\tbias += vec2(0.5, -0.5);\r\n\r\n\t// Convert from pixel coordinates to texcoords.\r\n\tscale *= 1.0 / SEARCHTEX_PACKED_SIZE;\r\n\tbias *= 1.0 / SEARCHTEX_PACKED_SIZE;\r\n\r\n\treturn texture2D(searchTexture, scale * e + bias).r;\r\n\r\n}\r\n\r\n/**\r\n * Horizontal search for the second pass.\r\n */\r\n\r\nfloat searchXLeft(in vec2 texCoord, const in float end) {\r\n\r\n\t/* @PSEUDO_GATHER4\r\n\tThis texCoord has been offset by (-0.25, -0.125) in the vertex shader to\r\n\tsample between edges, thus fetching four edges in a row.\r\n\tSampling with different offsets in each direction allows to disambiguate\r\n\twhich edges are active from the four fetched ones. */\r\n\r\n\tvec2 e = vec2(0.0, 1.0);\r\n\r\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\tif(!(texCoord.x > end && e.g > 0.8281 && e.r == 0.0)) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\te = texture2D(inputBuffer, texCoord).rg;\r\n\t\ttexCoord = vec2(-2.0, 0.0) * texelSize + texCoord;\r\n\r\n\t}\r\n\r\n\tfloat offset = -(255.0 / 127.0) * searchLength(e, 0.0) + 3.25;\r\n\r\n\treturn texelSize.x * offset + texCoord.x;\r\n\r\n\t// Non-optimized version:\r\n\t// Correct the previous (-0.25, -0.125) offset.\r\n\t// texCoord.x += 0.25 * texelSize.x;\r\n\t// The searches are biased by 1, so adjust the coords accordingly.\r\n\t// texCoord.x += texelSize.x;\r\n\t// Disambiguate the length added by the last step.\r\n\t// texCoord.x += 2.0 * texelSize.x; // Undo last step.\r\n\t// texCoord.x -= texelSize.x * (255.0 / 127.0) * searchLength(e, 0.0);\r\n\t// return texelSize.x * offset + texCoord.x);\r\n\r\n}\r\n\r\nfloat searchXRight(vec2 texCoord, const in float end) {\r\n\r\n\tvec2 e = vec2(0.0, 1.0);\r\n\r\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\tif(!(texCoord.x < end && e.g > 0.8281 && e.r == 0.0)) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\te = texture2D(inputBuffer, texCoord).rg;\r\n\t\ttexCoord = vec2(2.0, 0.0) * texelSize.xy + texCoord;\r\n\r\n\t}\r\n\r\n\tfloat offset = -(255.0 / 127.0) * searchLength(e, 0.5) + 3.25;\r\n\r\n\treturn -texelSize.x * offset + texCoord.x;\r\n\r\n}\r\n\r\n/**\r\n * Vertical search for the second pass.\r\n */\r\n\r\nfloat searchYUp(vec2 texCoord, const in float end) {\r\n\r\n\tvec2 e = vec2(1.0, 0.0);\r\n\r\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\tif(!(texCoord.y > end && e.r > 0.8281 && e.g == 0.0)) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\te = texture2D(inputBuffer, texCoord).rg;\r\n\t\ttexCoord = -vec2(0.0, 2.0) * texelSize.xy + texCoord;\r\n\r\n\t}\r\n\r\n\tfloat offset = -(255.0 / 127.0) * searchLength(e.gr, 0.0) + 3.25;\r\n\r\n\treturn texelSize.y * offset + texCoord.y;\r\n\r\n}\r\n\r\nfloat searchYDown(vec2 texCoord, const in float end) {\r\n\r\n\tvec2 e = vec2(1.0, 0.0);\r\n\r\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; i++) {\r\n\r\n\t\tif(!(texCoord.y < end && e.r > 0.8281 && e.g == 0.0)) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\te = texture2D(inputBuffer, texCoord).rg;\r\n\t\ttexCoord = vec2(0.0, 2.0) * texelSize.xy + texCoord;\r\n\r\n\t}\r\n\r\n\tfloat offset = -(255.0 / 127.0) * searchLength(e.gr, 0.5) + 3.25;\r\n\r\n\treturn -texelSize.y * offset + texCoord.y;\r\n\r\n}\r\n\r\n/**\r\n * Determines the areas at each side of the current edge.\r\n */\r\n\r\nvec2 area(const in vec2 dist, const in float e1, const in float e2, const in float offset) {\r\n\r\n\t// Rounding prevents precision errors of bilinear filtering.\r\n\tvec2 texCoord = vec2(AREATEX_MAX_DISTANCE) * round(4.0 * vec2(e1, e2)) + dist;\r\n\r\n\t// Apply a scale and bias for mapping to texel space.\r\n\ttexCoord = AREATEX_PIXEL_SIZE * texCoord + 0.5 * AREATEX_PIXEL_SIZE;\r\n\r\n\t// Move to the proper place, according to the subpixel offset.\r\n\ttexCoord.y = AREATEX_SUBTEX_SIZE * offset + texCoord.y;\r\n\r\n\treturn texture2D(areaTexture, texCoord).rg;\r\n\r\n}\r\n\r\n/**\r\n * Corner detection.\r\n */\r\n\r\nvoid detectHorizontalCornerPattern(inout vec2 weights, const in vec4 texCoord, const in vec2 d) {\r\n\r\n\t#if !defined(DISABLE_CORNER_DETECTION)\r\n\r\n\t\tvec2 leftRight = step(d.xy, d.yx);\r\n\t\tvec2 rounding = (1.0 - CORNER_ROUNDING_NORM) * leftRight;\r\n\r\n\t\t// Reduce blending for pixels in the center of a line.\r\n\t\trounding /= leftRight.x + leftRight.y;\r\n\r\n\t\tvec2 factor = vec2(1.0);\r\n\t\tfactor.x -= rounding.x * sampleLevelZeroOffset(inputBuffer, texCoord.xy, vec2(0, 1)).r;\r\n\t\tfactor.x -= rounding.y * sampleLevelZeroOffset(inputBuffer, texCoord.zw, vec2(1, 1)).r;\r\n\t\tfactor.y -= rounding.x * sampleLevelZeroOffset(inputBuffer, texCoord.xy, vec2(0, -2)).r;\r\n\t\tfactor.y -= rounding.y * sampleLevelZeroOffset(inputBuffer, texCoord.zw, vec2(1, -2)).r;\r\n\r\n\t\tweights *= clamp(factor, 0.0, 1.0);\r\n\r\n\t#endif\r\n\r\n}\r\n\r\nvoid detectVerticalCornerPattern(inout vec2 weights, const in vec4 texCoord, const in vec2 d) {\r\n\r\n\t#if !defined(DISABLE_CORNER_DETECTION)\r\n\r\n\t\tvec2 leftRight = step(d.xy, d.yx);\r\n\t\tvec2 rounding = (1.0 - CORNER_ROUNDING_NORM) * leftRight;\r\n\r\n\t\trounding /= leftRight.x + leftRight.y;\r\n\r\n\t\tvec2 factor = vec2(1.0);\r\n\t\tfactor.x -= rounding.x * sampleLevelZeroOffset(inputBuffer, texCoord.xy, vec2(1, 0)).g;\r\n\t\tfactor.x -= rounding.y * sampleLevelZeroOffset(inputBuffer, texCoord.zw, vec2(1, 1)).g;\r\n\t\tfactor.y -= rounding.x * sampleLevelZeroOffset(inputBuffer, texCoord.xy, vec2(-2, 0)).g;\r\n\t\tfactor.y -= rounding.y * sampleLevelZeroOffset(inputBuffer, texCoord.zw, vec2(-2, 1)).g;\r\n\r\n\t\tweights *= clamp(factor, 0.0, 1.0);\r\n\r\n\t#endif\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec4 weights = vec4(0.0);\r\n\tvec4 subsampleIndices = vec4(0.0);\r\n\tvec2 e = texture2D(inputBuffer, vUv).rg;\r\n\r\n\tif(e.g > 0.0) {\r\n\r\n\t\t// Edge at north.\r\n\r\n\t\t#if !defined(DISABLE_DIAG_DETECTION)\r\n\r\n\t\t\t/* Diagonals have both north and west edges, so searching for them in one of\r\n\t\t\tthe boundaries is enough. */\r\n\t\t\tweights.rg = calculateDiagWeights(vUv, e, subsampleIndices);\r\n\r\n\t\t\t// Skip horizontal/vertical processing if there is a diagonal.\r\n\t\t\tif(weights.r == -weights.g) { // weights.r + weights.g == 0.0\r\n\r\n\t\t#endif\r\n\r\n\t\tvec2 d;\r\n\r\n\t\t// Find the distance to the left.\r\n\t\tvec3 coords;\r\n\t\tcoords.x = searchXLeft(vOffset[0].xy, vOffset[2].x);\r\n\t\tcoords.y = vOffset[1].y; // vOffset[1].y = vUv.y - 0.25 * texelSize.y (@CROSSING_OFFSET)\r\n\t\td.x = coords.x;\r\n\r\n\t\t/* Now fetch the left crossing edges, two at a time using bilinear\r\n\t\tfiltering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to discern what\r\n\t\tvalue each edge has. */\r\n\t\tfloat e1 = texture2D(inputBuffer, coords.xy).r;\r\n\r\n\t\t// Find the distance to the right.\r\n\t\tcoords.z = searchXRight(vOffset[0].zw, vOffset[2].y);\r\n\t\td.y = coords.z;\r\n\r\n\t\t/* Translate distances to pixel units for better interleave arithmetic and\r\n\t\tmemory accesses. */\r\n\t\td = round(resolution.xx * d + -vPixCoord.xx);\r\n\r\n\t\t// The area texture is compressed quadratically.\r\n\t\tvec2 sqrtD = sqrt(abs(d));\r\n\r\n\t\t// Fetch the right crossing edges.\r\n\t\tfloat e2 = sampleLevelZeroOffset(inputBuffer, coords.zy, vec2(1, 0)).r;\r\n\r\n\t\t// Pattern recognized, now get the actual area.\r\n\t\tweights.rg = area(sqrtD, e1, e2, subsampleIndices.y);\r\n\r\n\t\t// Fix corners.\r\n\t\tcoords.y = vUv.y;\r\n\t\tdetectHorizontalCornerPattern(weights.rg, coords.xyzy, d);\r\n\r\n\t\t#if !defined(DISABLE_DIAG_DETECTION)\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Skip vertical processing.\r\n\t\t\t\te.r = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n\tif(e.r > 0.0) {\r\n\r\n\t\t// Edge at west.\r\n\r\n\t\tvec2 d;\r\n\r\n\t\t// Find the distance to the top.\r\n\t\tvec3 coords;\r\n\t\tcoords.y = searchYUp(vOffset[1].xy, vOffset[2].z);\r\n\t\tcoords.x = vOffset[0].x; // vOffset[1].x = vUv.x - 0.25 * texelSize.x;\r\n\t\td.x = coords.y;\r\n\r\n\t\t// Fetch the top crossing edges.\r\n\t\tfloat e1 = texture2D(inputBuffer, coords.xy).g;\r\n\r\n\t\t// Find the distance to the bottom.\r\n\t\tcoords.z = searchYDown(vOffset[1].zw, vOffset[2].w);\r\n\t\td.y = coords.z;\r\n\r\n\t\t// Translate distances into pixel units.\r\n\t\td = round(resolution.yy * d - vPixCoord.yy);\r\n\r\n\t\t// The area texture is compressed quadratically.\r\n\t\tvec2 sqrtD = sqrt(abs(d));\r\n\r\n\t\t// Fetch the bottom crossing edges.\r\n\t\tfloat e2 = sampleLevelZeroOffset(inputBuffer, coords.xz, vec2(0, 1)).g;\r\n\r\n\t\t// Get the area for this direction.\r\n\t\tweights.ba = area(sqrtD, e1, e2, subsampleIndices.x);\r\n\r\n\t\t// Fix corners.\r\n\t\tcoords.x = vUv.x;\r\n\t\tdetectVerticalCornerPattern(weights.ba, coords.xyxz, d);\r\n\r\n\t}\r\n\r\n\tgl_FragColor = weights;\r\n\r\n}\r\n",q="uniform vec2 texelSize;\r\nuniform vec2 resolution;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\nvarying vec2 vPixCoord;\r\n\r\nvoid main() {\r\n\r\n\tvUv = position.xy * 0.5 + 0.5;\r\n\tvPixCoord = vUv * resolution;\r\n\r\n\t// Offsets for the searches (see @PSEUDO_GATHER4).\r\n\tvOffset[0] = vUv.xyxy + texelSize.xyxy * vec4(-0.25, -0.125, 1.25, -0.125);\r\n\tvOffset[1] = vUv.xyxy + texelSize.xyxy * vec4(-0.125, -0.25, -0.125, 1.25);\r\n\r\n\t// This indicates the ends of the loops.\r\n\tvOffset[2] = vec4(vOffset[0].xz, vOffset[1].yw) +\r\n\t\tvec4(-2.0, 2.0, -2.0, 2.0) * texelSize.xxyy * MAX_SEARCH_STEPS_FLOAT;\r\n\r\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\r\n\r\n}\r\n",_=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new d.Vector2,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new d.Vector2;return(0,c.Z)(this,n),(e=t.call(this,{type:"SMAAWeightsMaterial",defines:{MAX_SEARCH_STEPS_INT:"16",MAX_SEARCH_STEPS_FLOAT:"16.0",MAX_SEARCH_STEPS_DIAG_INT:"8",MAX_SEARCH_STEPS_DIAG_FLOAT:"8.0",CORNER_ROUNDING:"25",CORNER_ROUNDING_NORM:"0.25",AREATEX_MAX_DISTANCE:"16.0",AREATEX_MAX_DISTANCE_DIAG:"20.0",AREATEX_PIXEL_SIZE:"(1.0 / vec2(160.0, 560.0))",AREATEX_SUBTEX_SIZE:"(1.0 / 7.0)",SEARCHTEX_SIZE:"vec2(66.0, 33.0)",SEARCHTEX_PACKED_SIZE:"vec2(64.0, 16.0)"},uniforms:{inputBuffer:new d.Uniform(null),areaTexture:new d.Uniform(null),searchTexture:new d.Uniform(null),texelSize:new d.Uniform(r),resolution:new d.Uniform(i)},fragmentShader:J,vertexShader:q,blending:d.NoBlending,depthWrite:!1,depthTest:!1})).toneMapped=!1,e}return(0,f.Z)(n,[{key:"setOrthogonalSearchSteps",value:function(e){var t=Math.min(Math.max(e,0),112);this.defines.MAX_SEARCH_STEPS_INT=t.toFixed("0"),this.defines.MAX_SEARCH_STEPS_FLOAT=t.toFixed("1"),this.needsUpdate=!0}},{key:"setDiagonalSearchSteps",value:function(e){var t=Math.min(Math.max(e,0),20);this.defines.MAX_SEARCH_STEPS_DIAG_INT=t.toFixed("0"),this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT=t.toFixed("1"),this.needsUpdate=!0}},{key:"setCornerRounding",value:function(e){var t=Math.min(Math.max(e,0),100);this.defines.CORNER_ROUNDING=t.toFixed("4"),this.defines.CORNER_ROUNDING_NORM=(t/100).toFixed("4"),this.needsUpdate=!0}},{key:"diagonalDetection",get:function(){return void 0===this.defines.DISABLE_DIAG_DETECTION},set:function(e){e?delete this.defines.DISABLE_DIAG_DETECTION:this.defines.DISABLE_DIAG_DETECTION="1",this.needsUpdate=!0}},{key:"cornerRounding",get:function(){return void 0===this.defines.DISABLE_CORNER_DETECTION},set:function(e){e?delete this.defines.DISABLE_CORNER_DETECTION:this.defines.DISABLE_CORNER_DETECTION="1",this.needsUpdate=!0}}]),n}(d.ShaderMaterial),$=function(e){(0,s.Z)(n,e);var t=g(n);function n(e){var r;return(0,c.Z)(this,n),(r=t.call(this,{type:"SSAOMaterial",defines:{SAMPLES_INT:"0",SAMPLES_FLOAT:"0.0",SPIRAL_TURNS:"0.0",RADIUS:"1.0",RADIUS_SQ:"1.0",DISTANCE_SCALING:"1",DEPTH_PACKING:"0"},uniforms:{normalBuffer:new d.Uniform(null),normalDepthBuffer:new d.Uniform(null),noiseTexture:new d.Uniform(null),inverseProjectionMatrix:new d.Uniform(new d.Matrix4),projectionMatrix:new d.Uniform(new d.Matrix4),texelSize:new d.Uniform(new d.Vector2),cameraNear:new d.Uniform(0),cameraFar:new d.Uniform(0),distanceCutoff:new d.Uniform(new d.Vector2),proximityCutoff:new d.Uniform(new d.Vector2),noiseScale:new d.Uniform(new d.Vector2),minRadiusScale:new d.Uniform(.33),intensity:new d.Uniform(1),fade:new d.Uniform(.01),bias:new d.Uniform(0)},fragmentShader:"#include <common>\r\n#include <packing>\r\n\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\r\n\tuniform highp sampler2D normalDepthBuffer;\r\n\r\n#else\r\n\r\n\tuniform mediump sampler2D normalDepthBuffer;\r\n\r\n#endif\r\n\r\n#ifndef NORMAL_DEPTH\r\n\r\n\tuniform sampler2D normalBuffer;\r\n\r\n\t// The depth texture is bound to normalDepthBuffer.\r\n\tfloat readDepth(const in vec2 uv) {\r\n\r\n\t\t#if DEPTH_PACKING == 3201\r\n\r\n\t\t\treturn unpackRGBAToDepth(texture2D(normalDepthBuffer, uv));\r\n\r\n\t\t#else\r\n\r\n\t\t\treturn texture2D(normalDepthBuffer, uv).r;\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n#endif\r\n\r\nuniform sampler2D noiseTexture;\r\n\r\nuniform mat4 inverseProjectionMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform vec2 texelSize;\r\n\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\nuniform float minRadiusScale;\r\nuniform float intensity;\r\nuniform float fade;\r\nuniform float bias;\r\n\r\nuniform vec2 distanceCutoff;\r\nuniform vec2 proximityCutoff;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vUv2;\r\n\r\nfloat getViewZ(const in float depth) {\r\n\r\n\t#ifdef PERSPECTIVE_CAMERA\r\n\r\n\t\treturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\r\n\r\n\t#else\r\n\r\n\t\treturn orthographicDepthToViewZ(depth, cameraNear, cameraFar);\r\n\r\n\t#endif\r\n\r\n}\r\n\r\nvec3 getViewPosition(const in vec2 screenPosition, const in float depth, const in float viewZ) {\r\n\r\n\tfloat clipW = projectionMatrix[2][3] * viewZ + projectionMatrix[3][3];\r\n\tvec4 clipPosition = vec4((vec3(screenPosition, depth) - 0.5) * 2.0, 1.0);\r\n\tclipPosition *= clipW; // Unproject.\r\n\r\n\treturn (inverseProjectionMatrix * clipPosition).xyz;\r\n\r\n}\r\n\r\nfloat getAmbientOcclusion(const in vec3 p, const in vec3 n, const in float depth, const in vec2 uv) {\r\n\r\n\t#ifdef DISTANCE_SCALING\r\n\r\n\t\tfloat radiusScale = 1.0 - smoothstep(0.0, distanceCutoff.y, depth);\r\n\t\tradiusScale = radiusScale * (1.0 - minRadiusScale) + minRadiusScale;\r\n\r\n\t\tfloat radius = RADIUS * radiusScale;\r\n\r\n\t#else\r\n\r\n\t\tfloat radius = RADIUS;\r\n\r\n\t#endif\r\n\r\n\t// Use a random starting angle.\r\n\tfloat noise = texture2D(noiseTexture, vUv2).r;\r\n\tfloat baseAngle = noise * PI2;\r\n\r\n\tfloat invSamples = 1.0 / SAMPLES_FLOAT;\r\n\tfloat rings = SPIRAL_TURNS * PI2;\r\n\r\n\tfloat occlusion = 0.0;\r\n\tint taps = 0;\r\n\r\n\tfor(int i = 0; i < SAMPLES_INT; ++i) {\r\n\r\n\t\tfloat alpha = (float(i) + 0.5) * invSamples;\r\n\t\tfloat angle = alpha * rings + baseAngle;\r\n\r\n\t\tvec2 coord = alpha * radius * vec2(cos(angle), sin(angle)) * texelSize + uv;\r\n\r\n\t\tif(coord.s < 0.0 || coord.s > 1.0 || coord.t < 0.0 || coord.t > 1.0) {\r\n\r\n\t\t\t// Skip samples outside the screen.\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\t#ifdef NORMAL_DEPTH\r\n\r\n\t\t\tfloat sampleDepth = texture2D(normalDepthBuffer, coord).a;\r\n\r\n\t\t#else\r\n\r\n\t\t\tfloat sampleDepth = readDepth(coord);\r\n\r\n\t\t#endif\r\n\r\n\t\tfloat viewZ = getViewZ(sampleDepth);\r\n\r\n\t\t#ifdef PERSPECTIVE_CAMERA\r\n\r\n\t\t\tfloat linearSampleDepth = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\r\n\r\n\t\t#else\r\n\r\n\t\t\tfloat linearSampleDepth = sampleDepth;\r\n\r\n\t\t#endif\r\n\r\n\t\tfloat proximity = abs(depth - linearSampleDepth);\r\n\r\n\t\tif(proximity < proximityCutoff.y) {\r\n\r\n\t\t\tfloat falloff = 1.0 - smoothstep(proximityCutoff.x, proximityCutoff.y, proximity);\r\n\r\n\t\t\tvec3 Q = getViewPosition(coord, sampleDepth, viewZ);\r\n\t\t\tvec3 v = Q - p;\r\n\r\n\t\t\tfloat vv = dot(v, v);\r\n\t\t\tfloat vn = dot(v, n) - bias;\r\n\r\n\t\t\tfloat f = max(RADIUS_SQ - vv, 0.0) / RADIUS_SQ;\r\n\t\t\tocclusion += (f * f * f * max(vn / (fade + vv), 0.0)) * falloff;\r\n\r\n\t\t}\r\n\r\n\t\t++taps;\r\n\r\n\t}\r\n\r\n\treturn occlusion / (4.0 * max(float(taps), 1.0));\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\t#ifdef NORMAL_DEPTH\r\n\r\n\t\tvec4 normalDepth = texture2D(normalDepthBuffer, vUv);\r\n\r\n\t#else\r\n\r\n\t\tvec4 normalDepth = vec4(\r\n\t\t\ttexture2D(normalBuffer, vUv).rgb,\r\n\t\t\treadDepth(vUv)\r\n\t\t);\r\n\r\n\t#endif\r\n\r\n\tfloat ao = 1.0;\r\n\tfloat depth = normalDepth.a;\r\n\tfloat viewZ = getViewZ(depth);\r\n\r\n\t#ifdef PERSPECTIVE_CAMERA\r\n\r\n\t\tfloat linearDepth = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\r\n\r\n\t#else\r\n\r\n\t\tfloat linearDepth = depth;\r\n\r\n\t#endif\r\n\r\n\t// Skip fragments that are too far away.\r\n\tif(linearDepth < distanceCutoff.y) {\r\n\r\n\t\tvec3 viewPosition = getViewPosition(vUv, depth, viewZ);\r\n\t\tvec3 viewNormal = unpackRGBToNormal(normalDepth.rgb);\r\n\t\tao -= getAmbientOcclusion(viewPosition, viewNormal, linearDepth, vUv);\r\n\r\n\t\t// Fade AO based on depth.\r\n\t\tfloat d = smoothstep(distanceCutoff.x, distanceCutoff.y, linearDepth);\r\n\t\tao = mix(ao, 1.0, d);\r\n\r\n\t\t// Adjust the overall intensity.\r\n\t\tao = clamp(pow(ao, abs(intensity)), 0.0, 1.0);\r\n\r\n\t}\r\n\r\n\tgl_FragColor.r = ao;\r\n\r\n}\r\n",vertexShader:"uniform vec2 noiseScale;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vUv2;\r\n\r\nvoid main() {\r\n\r\n\tvUv = position.xy * 0.5 + 0.5;\r\n\tvUv2 = vUv * noiseScale;\r\n\r\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\r\n\r\n}\r\n",blending:d.NoBlending,depthWrite:!1,depthTest:!1})).toneMapped=!1,r.adoptCameraSettings(e),r}return(0,f.Z)(n,[{key:"depthPacking",get:function(){return Number(this.defines.DEPTH_PACKING)},set:function(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}},{key:"setTexelSize",value:function(e,t){this.uniforms.texelSize.value.set(e,t)}},{key:"adoptCameraSettings",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(null!==e){var t=this.uniforms;t.cameraNear.value=e.near,t.cameraFar.value=e.far,e instanceof d.PerspectiveCamera?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0}}}]),n}(d.ShaderMaterial),ee=new d.Camera,te=null;var ne=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Pass",n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new d.Scene,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:ee;(0,c.Z)(this,e),this.name=t,this.scene=n,this.camera=r,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}return(0,f.Z)(e,[{key:"renderToScreen",get:function(){return!this.rtt},set:function(e){if(this.rtt===e){var t=this.getFullscreenMaterial();null!==t&&(t.needsUpdate=!0),this.rtt=!e}}},{key:"getFullscreenMaterial",value:function(){return null!==this.screen?this.screen.material:null}},{key:"setFullscreenMaterial",value:function(e){var t=this.screen;null!==t?t.material=e:((t=new d.Mesh(function(){if(null===te){var e=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t=new Float32Array([0,0,2,0,0,2]);void 0!==(te=new d.BufferGeometry).setAttribute?(te.setAttribute("position",new d.BufferAttribute(e,3)),te.setAttribute("uv",new d.BufferAttribute(t,2))):(te.addAttribute("position",new d.BufferAttribute(e,3)),te.addAttribute("uv",new d.BufferAttribute(t,2)))}return te}(),e)).frustumCulled=!1,null===this.scene&&(this.scene=new d.Scene),this.scene.add(t),this.screen=t)}},{key:"getDepthTexture",value:function(){return null}},{key:"setDepthTexture",value:function(e){}},{key:"render",value:function(e,t,n,r,i){throw new Error("Render method not implemented!")}},{key:"setSize",value:function(e,t){}},{key:"initialize",value:function(e,t,n){}},{key:"dispose",value:function(){var e=this.getFullscreenMaterial();null!==e&&e.dispose();for(var t=0,n=Object.keys(this);t<n.length;t++){var r=n[t],i=this[r];if(null!==i&&"function"==typeof i.dispose){if(i instanceof d.Scene)continue;this[r].dispose()}}}}]),e}(),re=function(e){(0,s.Z)(n,e);var t=g(n);function n(e){var r,i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return(0,c.Z)(this,n),(r=t.call(this,"SavePass")).setFullscreenMaterial(new b),r.needsSwap=!1,r.renderTarget=e,void 0===e&&(r.renderTarget=new d.WebGLRenderTarget(1,1,{minFilter:d.LinearFilter,magFilter:d.LinearFilter,stencilBuffer:!1,depthBuffer:!1}),r.renderTarget.texture.name="SavePass.Target"),r.resize=i,r}return(0,f.Z)(n,[{key:"texture",get:function(){return this.renderTarget.texture}},{key:"render",value:function(e,t,n,r,i){this.getFullscreenMaterial().uniforms.inputBuffer.value=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}},{key:"setSize",value:function(e,t){if(this.resize){var n=Math.max(e,1),r=Math.max(t,1);this.renderTarget.setSize(n,r)}}},{key:"initialize",value:function(e,t,n){t||n!==d.UnsignedByteType||(this.renderTarget.texture.format=d.RGBFormat),void 0!==n&&(this.renderTarget.texture.type=n)}}]),n}(ne),ie=function(e){(0,s.Z)(n,e);var t=g(n);function n(e){var r,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=i.minLuminance,o=void 0===a?.01:a,s=i.adaptationRate,l=void 0===s?1:s;(0,c.Z)(this,n),(r=t.call(this,"AdaptiveLuminancePass")).setFullscreenMaterial(new w),r.needsSwap=!1,r.renderTargetPrevious=new d.WebGLRenderTarget(1,1,{minFilter:d.NearestFilter,magFilter:d.NearestFilter,type:d.HalfFloatType,stencilBuffer:!1,depthBuffer:!1,format:d.RGBAFormat}),r.renderTargetPrevious.texture.name="Luminance.Previous";var u=r.getFullscreenMaterial().uniforms;return u.luminanceBuffer0.value=r.renderTargetPrevious.texture,u.luminanceBuffer1.value=e,u.minLuminance.value=o,r.renderTargetAdapted=r.renderTargetPrevious.clone(),r.renderTargetAdapted.texture.name="Luminance.Adapted",r.savePass=new re(r.renderTargetPrevious,!1),r.adaptationRate=l,r}return(0,f.Z)(n,[{key:"texture",get:function(){return this.renderTargetAdapted.texture}},{key:"mipLevel1x1",set:function(e){var t=this.getFullscreenMaterial();t.defines.MIP_LEVEL_1X1=e.toFixed(1),t.needsUpdate=!0}},{key:"adaptationRate",get:function(){return this.getFullscreenMaterial().uniforms.tau.value},set:function(e){this.getFullscreenMaterial().uniforms.tau.value=e}},{key:"render",value:function(e,t,n,r,i){this.getFullscreenMaterial().uniforms.deltaTime.value=r,e.setRenderTarget(this.renderToScreen?null:this.renderTargetAdapted),e.render(this.scene,this.camera),this.savePass.render(e,this.renderTargetAdapted)}},{key:"initialize",value:function(e,t,n){if(n!==d.HalfFloatType){var r=e.capabilities,i=e.getContext();r.isWebGL2?i.getExtension("EXT_color_buffer_float"):i.getExtension("EXT_color_buffer_half_float")}}}]),n}(ne),ae=-1,oe=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ae,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:ae,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;(0,c.Z)(this,e),this.resizable=t,this.base=new d.Vector2(1,1),this.target=new d.Vector2(n,r),this.s=i}return(0,f.Z)(e,[{key:"scale",get:function(){return this.s},set:function(e){this.s=e,this.target.x=ae,this.target.y=ae,this.resizable.setSize(this.base.x,this.base.y)}},{key:"width",get:function(){var e=this.base,t=this.target;return t.x!==ae?t.x:t.y!==ae?Math.round(t.y*(e.x/e.y)):Math.round(e.x*this.s)},set:function(e){this.target.x=e,this.resizable.setSize(this.base.x,this.base.y)}},{key:"height",get:function(){var e=this.base,t=this.target;return t.y!==ae?t.y:t.x!==ae?Math.round(t.x/(e.x/e.y)):Math.round(e.y*this.s)},set:function(e){this.target.y=e,this.resizable.setSize(this.base.x,this.base.y)}}],[{key:"AUTO_SIZE",get:function(){return ae}}]),e}(),se=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=r.resolutionScale,a=void 0===i?.5:i,s=r.width,l=void 0===s?oe.AUTO_SIZE:s,u=r.height,f=void 0===u?oe.AUTO_SIZE:u,h=r.kernelSize,v=void 0===h?F.LARGE:h;return(0,c.Z)(this,n),(e=t.call(this,"BlurPass")).renderTargetA=new d.WebGLRenderTarget(1,1,{minFilter:d.LinearFilter,magFilter:d.LinearFilter,stencilBuffer:!1,depthBuffer:!1}),e.renderTargetA.texture.name="Blur.Target.A",e.renderTargetB=e.renderTargetA.clone(),e.renderTargetB.texture.name="Blur.Target.B",e.resolution=new oe((0,o.Z)(e),l,f,a),e.convolutionMaterial=new P,e.ditheredConvolutionMaterial=new P,e.ditheredConvolutionMaterial.dithering=!0,e.dithering=!1,e.kernelSize=v,e}return(0,f.Z)(n,[{key:"width",get:function(){return this.resolution.width},set:function(e){this.resolution.width=e}},{key:"height",get:function(){return this.resolution.height},set:function(e){this.resolution.height=e}},{key:"scale",get:function(){return this.convolutionMaterial.uniforms.scale.value},set:function(e){this.convolutionMaterial.uniforms.scale.value=e,this.ditheredConvolutionMaterial.uniforms.scale.value=e}},{key:"kernelSize",get:function(){return this.convolutionMaterial.kernelSize},set:function(e){this.convolutionMaterial.kernelSize=e,this.ditheredConvolutionMaterial.kernelSize=e}},{key:"getResolutionScale",value:function(){return this.resolution.scale}},{key:"setResolutionScale",value:function(e){this.resolution.scale=e}},{key:"render",value:function(e,t,n,r,i){var a,o,s,l=this.scene,u=this.camera,c=this.renderTargetA,f=this.renderTargetB,d=this.convolutionMaterial,h=d.uniforms,v=d.getKernel(),g=t;for(this.setFullscreenMaterial(d),o=0,s=v.length-1;o<s;++o)a=0==(1&o)?c:f,h.kernel.value=v[o],h.inputBuffer.value=g.texture,e.setRenderTarget(a),e.render(l,u),g=a;this.dithering&&(h=(d=this.ditheredConvolutionMaterial).uniforms,this.setFullscreenMaterial(d)),h.kernel.value=v[o],h.inputBuffer.value=g.texture,e.setRenderTarget(this.renderToScreen?null:n),e.render(l,u)}},{key:"setSize",value:function(e,t){var n=this.resolution;n.base.set(e,t);var r=n.width,i=n.height;this.renderTargetA.setSize(r,i),this.renderTargetB.setSize(r,i),this.convolutionMaterial.setTexelSize(1/r,1/i),this.ditheredConvolutionMaterial.setTexelSize(1/r,1/i)}},{key:"initialize",value:function(e,t,n){t||n!==d.UnsignedByteType||(this.renderTargetA.texture.format=d.RGBFormat,this.renderTargetB.texture.format=d.RGBFormat),void 0!==n&&(this.renderTargetA.texture.type=n,this.renderTargetB.texture.type=n)}}],[{key:"AUTO_SIZE",get:function(){return oe.AUTO_SIZE}}]),n}(ne),le=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e;return(0,c.Z)(this,n),(e=t.call(this,"ClearMaskPass",null,null)).needsSwap=!1,e}return(0,f.Z)(n,[{key:"render",value:function(e,t,n,r,i){var a=e.state.buffers.stencil;a.setLocked(!1),a.setTest(!1)}}]),n}(ne),ue=new d.Color,ce=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return(0,c.Z)(this,n),(e=t.call(this,"ClearPass",null,null)).needsSwap=!1,e.color=r,e.depth=i,e.stencil=a,e.overrideClearColor=null,e.overrideClearAlpha=-1,e}return(0,f.Z)(n,[{key:"render",value:function(e,t,n,r,i){var a=this.overrideClearColor,o=this.overrideClearAlpha,s=e.getClearAlpha(),l=null!==a,u=o>=0;l?(ue.copy(e.getClearColor(ue)),e.setClearColor(a,u?o:s)):u&&e.setClearAlpha(o),e.setRenderTarget(this.renderToScreen?null:t),e.clear(this.color,this.depth,this.stencil),l?e.setClearColor(ue,s):u&&e.setClearAlpha(s)}}]),n}(ne),fe=!1,de=function(){function e(){var t=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;(0,c.Z)(this,e),this.originalMaterials=new Map,this.material=null,this.materialInstanced=null,this.materialSkinning=null,this.setMaterial(n),this.meshCount=0,this.replaceMaterial=function(e){e.isMesh&&(t.originalMaterials.set(e,e.material),e.isInstancedMesh?e.material=t.materialInstanced:e.isSkinnedMesh?e.material=t.materialSkinning:e.material=t.material,++t.meshCount)}}return(0,f.Z)(e,[{key:"setMaterial",value:function(e){this.disposeMaterials(),null!==e&&(this.material=e,this.materialInstanced=e.clone(),this.materialInstanced.uniforms=Object.assign({},e.uniforms),this.materialSkinning=e.clone(),this.materialSkinning.uniforms=Object.assign({},e.uniforms),this.materialSkinning.skinning=!0)}},{key:"render",value:function(e,t,n){var r=e.shadowMap.enabled;if(e.shadowMap.enabled=!1,fe){var i=this.originalMaterials;this.meshCount=0,t.traverse(this.replaceMaterial),e.render(t,n);var a,o=h(i);try{for(o.s();!(a=o.n()).done;){var s=a.value;s[0].material=s[1]}}catch(u){o.e(u)}finally{o.f()}this.meshCount!==i.size&&i.clear()}else{var l=t.overrideMaterial;t.overrideMaterial=this.material,e.render(t,n),t.overrideMaterial=l}e.shadowMap.enabled=r}},{key:"disposeMaterials",value:function(){null!==this.materialInstanced&&this.materialInstanced.dispose(),null!==this.materialSkinning&&this.materialSkinning.dispose()}},{key:"dispose",value:function(){this.originalMaterials.clear(),this.disposeMaterials()}}],[{key:"workaroundEnabled",get:function(){return fe},set:function(e){fe=e}}]),e}(),he=function(e){(0,s.Z)(n,e);var t=g(n);function n(e,r){var i,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;return(0,c.Z)(this,n),(i=t.call(this,"RenderPass",e,r)).needsSwap=!1,i.clearPass=new ce,i.overrideMaterialManager=null===a?null:new de(a),i}return(0,f.Z)(n,[{key:"renderToScreen",get:function(){return(0,a.Z)((0,u.Z)(n.prototype),"renderToScreen",this)},set:function(e){(0,i.Z)((0,u.Z)(n.prototype),"renderToScreen",e,this,!0),this.clearPass.renderToScreen=e}},{key:"overrideMaterial",get:function(){var e=this.overrideMaterialManager;return null!==e?e.material:null},set:function(e){var t=this.overrideMaterialManager;null!==e?null!==t?t.setMaterial(e):this.overrideMaterialManager=new de(e):null!==t&&(t.dispose(),this.overrideMaterialManager=null)}},{key:"clear",get:function(){return this.clearPass.enabled},set:function(e){this.clearPass.enabled=e}},{key:"getClearPass",value:function(){return this.clearPass}},{key:"render",value:function(e,t,n,r,i){var a=this.scene,o=this.camera,s=a.background,l=this.renderToScreen?null:t;this.clear&&(null!==this.clearPass.overrideClearColor&&(a.background=null),this.clearPass.render(e,t)),e.setRenderTarget(l),null!==this.overrideMaterialManager?this.overrideMaterialManager.render(e,a,o):e.render(a,o),a.background!==s&&(a.background=s)}}]),n}(ne),ve=function(e){(0,s.Z)(n,e);var t=g(n);function n(e,r){var i,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},s=a.resolutionScale,l=void 0===s?1:s,u=a.width,f=void 0===u?oe.AUTO_SIZE:u,h=a.height,v=void 0===h?oe.AUTO_SIZE:h,g=a.renderTarget;(0,c.Z)(this,n),(i=t.call(this,"DepthPass")).needsSwap=!1,i.renderPass=new he(e,r,new d.MeshDepthMaterial({depthPacking:d.RGBADepthPacking}));var A=i.renderPass.getClearPass();return A.overrideClearColor=new d.Color(16777215),A.overrideClearAlpha=1,i.renderTarget=g,void 0===i.renderTarget&&(i.renderTarget=new d.WebGLRenderTarget(1,1,{minFilter:d.NearestFilter,magFilter:d.NearestFilter,stencilBuffer:!1}),i.renderTarget.texture.name="DepthPass.Target"),i.resolution=new oe((0,o.Z)(i),f,v,l),i}return(0,f.Z)(n,[{key:"texture",get:function(){return this.renderTarget.texture}},{key:"getResolutionScale",value:function(){return this.resolutionScale}},{key:"setResolutionScale",value:function(e){this.resolutionScale=e,this.setSize(this.resolution.base.x,this.resolution.base.y)}},{key:"render",value:function(e,t,n,r,i){var a=this.renderToScreen?null:this.renderTarget;this.renderPass.render(e,a)}},{key:"setSize",value:function(e,t){var n=this.resolution;n.base.set(e,t),this.renderTarget.setSize(n.width,n.height)}}]),n}(ne),ge={SKIP:0,ADD:1,ALPHA:2,AVERAGE:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,EXCLUSION:8,LIGHTEN:9,MULTIPLY:10,DIVIDE:11,NEGATION:12,NORMAL:13,OVERLAY:14,REFLECT:15,SCREEN:16,SOFT_LIGHT:17,SUBTRACT:18},Ae=new Map([[ge.SKIP,null],[ge.ADD,"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn min(x + y, 1.0) * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.ALPHA,"vec3 blend(const in vec3 x, const in vec3 y, const in float opacity) {\r\n\r\n\treturn y * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n\r\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tfloat a = min(y.a, opacity);\r\n\r\n\treturn vec4(blend(x.rgb, y.rgb, a), max(x.a, a));\r\n\r\n}\r\n"],[ge.AVERAGE,"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn (x + y) * 0.5 * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.COLOR_BURN,"float blend(const in float x, const in float y) {\r\n\r\n\treturn (y == 0.0) ? y : max(1.0 - (1.0 - x) / y, 0.0);\r\n\r\n}\r\n\r\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tvec4 z = vec4(blend(x.r, y.r), blend(x.g, y.g), blend(x.b, y.b), blend(x.a, y.a));\r\n\r\n\treturn z * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.COLOR_DODGE,"float blend(const in float x, const in float y) {\r\n\r\n\treturn (y == 1.0) ? y : min(x / (1.0 - y), 1.0);\r\n\r\n}\r\n\r\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tvec4 z = vec4(blend(x.r, y.r), blend(x.g, y.g), blend(x.b, y.b), blend(x.a, y.a));\r\n\r\n\treturn z * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.DARKEN,"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn min(x, y) * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.DIFFERENCE,"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn abs(x - y) * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.EXCLUSION,"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn (x + y - 2.0 * x * y) * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.LIGHTEN,"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn max(x, y) * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.MULTIPLY,"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn x * y * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.DIVIDE,"float blend(const in float x, const in float y) {\r\n\r\n\treturn (y > 0.0) ? min(x / y, 1.0) : 1.0;\r\n\r\n}\r\n\r\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tvec4 z = vec4(blend(x.r, y.r), blend(x.g, y.g), blend(x.b, y.b), blend(x.a, y.a));\r\n\r\n\treturn z * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.NEGATION,"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn (1.0 - abs(1.0 - x - y)) * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.NORMAL,"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn y * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.OVERLAY,"float blend(const in float x, const in float y) {\r\n\r\n\treturn (x < 0.5) ? (2.0 * x * y) : (1.0 - 2.0 * (1.0 - x) * (1.0 - y));\r\n\r\n}\r\n\r\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tvec4 z = vec4(blend(x.r, y.r), blend(x.g, y.g), blend(x.b, y.b), blend(x.a, y.a));\r\n\r\n\treturn z * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.REFLECT,"float blend(const in float x, const in float y) {\r\n\r\n\treturn (y == 1.0) ? y : min(x * x / (1.0 - y), 1.0);\r\n\r\n}\r\n\r\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tvec4 z = vec4(blend(x.r, y.r), blend(x.g, y.g), blend(x.b, y.b), blend(x.a, y.a));\r\n\r\n\treturn z * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.SCREEN,"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn (1.0 - (1.0 - x) * (1.0 - y)) * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.SOFT_LIGHT,"float blend(const in float x, const in float y) {\r\n\r\n\treturn (y < 0.5) ?\r\n\t\t(2.0 * x * y + x * x * (1.0 - 2.0 * y)) :\r\n\t\t(sqrt(x) * (2.0 * y - 1.0) + 2.0 * x * (1.0 - y));\r\n\r\n}\r\n\r\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tvec4 z = vec4(blend(x.r, y.r), blend(x.g, y.g), blend(x.b, y.b), blend(x.a, y.a));\r\n\r\n\treturn z * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"],[ge.SUBTRACT,"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn max(x + y - 1.0, 0.0) * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n"]]),me=function(e){(0,s.Z)(n,e);var t=g(n);function n(e){var r,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(0,c.Z)(this,n),(r=t.call(this)).blendFunction=e,r.opacity=new d.Uniform(i),r}return(0,f.Z)(n,[{key:"getBlendFunction",value:function(){return this.blendFunction}},{key:"setBlendFunction",value:function(e){this.blendFunction=e,this.dispatchEvent({type:"change"})}},{key:"getShaderCode",value:function(){return Ae.get(this.blendFunction)}}]),n}(d.EventDispatcher),pe=function(e){(0,s.Z)(n,e);var t=g(n);function n(e,r){var i,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=a.attributes,s=void 0===o?ye.NONE:o,l=a.blendFunction,u=void 0===l?ge.SCREEN:l,f=a.defines,d=void 0===f?new Map:f,h=a.uniforms,v=void 0===h?new Map:h,g=a.extensions,A=void 0===g?null:g,m=a.vertexShader,p=void 0===m?null:m;return(0,c.Z)(this,n),(i=t.call(this)).name=e,i.attributes=s,i.fragmentShader=r,i.vertexShader=p,i.defines=d,i.uniforms=v,i.extensions=A,i.blendMode=new me(u),i.blendMode.addEventListener("change",(function(e){return i.setChanged()})),i}return(0,f.Z)(n,[{key:"setChanged",value:function(){this.dispatchEvent({type:"change"})}},{key:"getAttributes",value:function(){return this.attributes}},{key:"setAttributes",value:function(e){this.attributes=e,this.setChanged()}},{key:"getFragmentShader",value:function(){return this.fragmentShader}},{key:"setFragmentShader",value:function(e){this.fragmentShader=e,this.setChanged()}},{key:"getVertexShader",value:function(){return this.vertexShader}},{key:"setVertexShader",value:function(e){this.vertexShader=e,this.setChanged()}},{key:"setDepthTexture",value:function(e){}},{key:"update",value:function(e,t,n){}},{key:"setSize",value:function(e,t){}},{key:"initialize",value:function(e,t,n){}},{key:"dispose",value:function(){for(var e=0,t=Object.keys(this);e<t.length;e++){var n=t[e],r=this[n];if(null!==r&&"function"==typeof r.dispose){if(r instanceof d.Scene)continue;this[n].dispose()}}}}]),n}(d.EventDispatcher),ye={NONE:0,DEPTH:1,CONVOLUTION:2};function xe(e,t){for(var n,r=[];null!==(n=e.exec(t));)r.push(n[1]);return r}function we(e,t,n){var r,i,a,o=h(t);try{for(o.s();!(a=o.n()).done;){var s=a.value;r="$1"+e+s.charAt(0).toUpperCase()+s.slice(1),i=new RegExp("([^\\.])(\\b"+s+"\\b)","g");var l,u=h(n.entries());try{for(u.s();!(l=u.n()).done;){var c=l.value;null!==c[1]&&n.set(c[0],c[1].replace(i,r))}}catch(f){u.e(f)}finally{u.f()}}}catch(f){o.e(f)}finally{o.f()}}function Ce(e,t,n,r,i,a,o){var s=/(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g,l=t.blendMode,u=new Map([["fragment",t.getFragmentShader()],["vertex",t.getVertexShader()]]),c=void 0!==u.get("fragment")&&/mainImage/.test(u.get("fragment")),f=void 0!==u.get("fragment")&&/mainUv/.test(u.get("fragment")),d=[],h=[],v=!1,g=!1;if(void 0===u.get("fragment"))console.error("Missing fragment shader",t);else if(f&&0!=(o&ye.CONVOLUTION))console.error("Effects that transform UV coordinates are incompatible with convolution effects",t);else if(c||f){if(f&&(n.set(H.FRAGMENT_MAIN_UV,n.get(H.FRAGMENT_MAIN_UV)+"\t"+e+"MainUv(UV);\n"),v=!0),null!==u.get("vertex")&&/mainSupport/.test(u.get("vertex"))){var A="\t"+e+"MainSupport(";/mainSupport *\([\w\s]*?uv\s*?\)/.test(u.get("vertex"))&&(A+="vUv"),A+=");\n",n.set(H.VERTEX_MAIN_SUPPORT,n.get(H.VERTEX_MAIN_SUPPORT)+A),d=d.concat(xe(/(?:varying\s+\w+\s+(\w*))/g,u.get("vertex"))),h=h.concat(d).concat(xe(s,u.get("vertex")))}if(h=h.concat(xe(s,u.get("fragment"))).concat(Array.from(t.defines.keys()).map((function(e){return e.replace(/\([\w\s,]*\)/g,"")}))).concat(Array.from(t.uniforms.keys())),t.uniforms.forEach((function(t,n){return a.set(e+n.charAt(0).toUpperCase()+n.slice(1),t)})),t.defines.forEach((function(t,n){return i.set(e+n.charAt(0).toUpperCase()+n.slice(1),t)})),we(e,h,i),we(e,h,u),r.set(l.blendFunction,l),c){var m=e+"MainImage(color0, UV, ";0!=(o&ye.DEPTH)&&/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/.test(u.get("fragment"))&&(m+="depth, ",g=!0),m+="color1);\n\t";var p=e+"BlendOpacity";a.set(p,l.opacity),m+="color0 = blend"+l.getBlendFunction()+"(color0, color1, "+p+");\n\n\t",n.set(H.FRAGMENT_MAIN_IMAGE,n.get(H.FRAGMENT_MAIN_IMAGE)+m),n.set(H.FRAGMENT_HEAD,n.get(H.FRAGMENT_HEAD)+"uniform float "+p+";\n\n")}n.set(H.FRAGMENT_HEAD,n.get(H.FRAGMENT_HEAD)+u.get("fragment")+"\n"),null!==u.get("vertex")&&n.set(H.VERTEX_HEAD,n.get(H.VERTEX_HEAD)+u.get("vertex")+"\n")}else console.error("The fragment shader contains neither a mainImage nor a mainUv function",t);return{varyings:d,transformedUv:v,readDepth:g}}var De=function(e){(0,s.Z)(n,e);var t=g(n);function n(e){var r;(0,c.Z)(this,n),(r=t.call(this,"EffectPass")).setFullscreenMaterial(new N(null,null,null,e));for(var i=arguments.length,a=new Array(i>1?i-1:0),o=1;o<i;o++)a[o-1]=arguments[o];return r.effects=a.sort((function(e,t){return t.attributes-e.attributes})),r.skipRendering=!1,r.uniforms=0,r.varyings=0,r.minTime=1,r.maxTime=Number.POSITIVE_INFINITY,r}return(0,f.Z)(n,[{key:"encodeOutput",get:function(){return void 0!==this.getFullscreenMaterial().defines.ENCODE_OUTPUT},set:function(e){if(this.encodeOutput!==e){var t=this.getFullscreenMaterial();t.needsUpdate=!0,e?t.defines.ENCODE_OUTPUT="1":delete t.defines.ENCODE_OUTPUT}}},{key:"dithering",get:function(){return this.getFullscreenMaterial().dithering},set:function(e){var t=this.getFullscreenMaterial();t.dithering!==e&&(t.dithering=e,t.needsUpdate=!0)}},{key:"verifyResources",value:function(e){var t=e.capabilities,n=Math.min(t.maxFragmentUniforms,t.maxVertexUniforms);this.uniforms>n&&console.warn("The current rendering context doesn't support more than "+n+" uniforms, but "+this.uniforms+" were defined"),n=t.maxVaryings,this.varyings>n&&console.warn("The current rendering context doesn't support more than "+n+" varyings, but "+this.varyings+" were defined")}},{key:"updateMaterial",value:function(){var e,t,n=/\bblend\b/g,r=new Map([[H.FRAGMENT_HEAD,""],[H.FRAGMENT_MAIN_UV,""],[H.FRAGMENT_MAIN_IMAGE,""],[H.VERTEX_HEAD,""],[H.VERTEX_MAIN_SUPPORT,""]]),i=new Map,a=new Map,o=new Map,s=new Set,l=0,u=0,c=0,f=!1,d=!1,v=h(this.effects);try{for(v.s();!(t=v.n()).done;){var g=t.value;if(g.blendMode.getBlendFunction()===ge.SKIP)c|=g.getAttributes()&ye.DEPTH;else if(0!=(c&ye.CONVOLUTION)&&0!=(g.getAttributes()&ye.CONVOLUTION))console.error("Convolution effects cannot be merged",g);else if(c|=g.getAttributes(),u+=(e=Ce("e"+l++,g,r,i,a,o,c)).varyings.length,f=f||e.transformedUv,d=d||e.readDepth,null!==g.extensions){var A,m=h(g.extensions);try{for(m.s();!(A=m.n()).done;){var p=A.value;s.add(p)}}catch(T){m.e(T)}finally{m.f()}}}}catch(T){v.e(T)}finally{v.f()}var y,x=h(i.values());try{for(x.s();!(y=x.n()).done;){var w=y.value;r.set(H.FRAGMENT_HEAD,r.get(H.FRAGMENT_HEAD)+w.getShaderCode().replace(n,"blend"+w.getBlendFunction())+"\n")}}catch(T){x.e(T)}finally{x.f()}0!=(c&ye.DEPTH)?(d&&r.set(H.FRAGMENT_MAIN_IMAGE,"float depth = readDepth(UV);\n\n\t"+r.get(H.FRAGMENT_MAIN_IMAGE)),this.needsDepthTexture=null===this.getDepthTexture()):this.needsDepthTexture=!1,f?(r.set(H.FRAGMENT_MAIN_UV,"vec2 transformedUv = vUv;\n"+r.get(H.FRAGMENT_MAIN_UV)),a.set("UV","transformedUv")):a.set("UV","vUv"),r.forEach((function(e,t,n){return n.set(t,e.trim().replace(/^#/,"\n#"))})),this.uniforms=o.size,this.varyings=u,this.skipRendering=0===l,this.needsSwap=!this.skipRendering;var C=this.getFullscreenMaterial();if(C.setShaderParts(r).setDefines(a).setUniforms(o),C.extensions={},s.size>0){var D,E=h(s);try{for(E.s();!(D=E.n()).done;){var B=D.value;C.extensions[B]=!0}}catch(T){E.e(T)}finally{E.f()}}this.needsUpdate=!1}},{key:"recompile",value:function(e){this.updateMaterial(),void 0!==e&&this.verifyResources(e)}},{key:"getDepthTexture",value:function(){return this.getFullscreenMaterial().uniforms.depthBuffer.value}},{key:"setDepthTexture",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=this.getFullscreenMaterial();n.uniforms.depthBuffer.value=e,n.depthPacking=t,n.needsUpdate=!0;var r,i=h(this.effects);try{for(i.s();!(r=i.n()).done;){var a=r.value;a.setDepthTexture(e,t)}}catch(o){i.e(o)}finally{i.f()}}},{key:"render",value:function(e,t,n,r,i){var a=this.getFullscreenMaterial(),o=a.uniforms.time.value+r;this.needsUpdate&&this.recompile(e);var s,l=h(this.effects);try{for(l.s();!(s=l.n()).done;){s.value.update(e,t,r)}}catch(u){l.e(u)}finally{l.f()}this.skipRendering&&!this.renderToScreen||(a.uniforms.inputBuffer.value=t.texture,a.uniforms.time.value=o<=this.maxTime?o:this.minTime,e.setRenderTarget(this.renderToScreen?null:n),e.render(this.scene,this.camera))}},{key:"setSize",value:function(e,t){this.getFullscreenMaterial().setSize(e,t);var n,r=h(this.effects);try{for(r.s();!(n=r.n()).done;){n.value.setSize(e,t)}}catch(i){r.e(i)}finally{r.f()}}},{key:"initialize",value:function(e,t,n){var r=this;this.capabilities=e.capabilities;var i,a=h(this.effects);try{for(a.s();!(i=a.n()).done;){var o=i.value;o.initialize(e,t,n),o.addEventListener("change",(function(e){return r.handleEvent(e)}))}}catch(s){a.e(s)}finally{a.f()}this.updateMaterial(),this.verifyResources(e)}},{key:"dispose",value:function(){(0,a.Z)((0,u.Z)(n.prototype),"dispose",this).call(this);var e,t=h(this.effects);try{for(t.s();!(e=t.n()).done;){e.value.dispose()}}catch(r){t.e(r)}finally{t.f()}}},{key:"handleEvent",value:function(e){if("change"===e.type)this.needsUpdate=!0}}]),n}(ne),Ee=function(e){(0,s.Z)(n,e);var t=g(n);function n(e,r){var i;return(0,c.Z)(this,n),(i=t.call(this,"MaskPass",e,r)).needsSwap=!1,i.clearPass=new ce(!1,!1,!0),i.inverse=!1,i}return(0,f.Z)(n,[{key:"clear",get:function(){return this.clearPass.enabled},set:function(e){this.clearPass.enabled=e}},{key:"render",value:function(e,t,n,r,i){var a=e.getContext(),o=e.state.buffers,s=this.scene,l=this.camera,u=this.clearPass,c=this.inverse?0:1,f=1-c;o.color.setMask(!1),o.depth.setMask(!1),o.color.setLocked(!0),o.depth.setLocked(!0),o.stencil.setTest(!0),o.stencil.setOp(a.REPLACE,a.REPLACE,a.REPLACE),o.stencil.setFunc(a.ALWAYS,c,4294967295),o.stencil.setClear(f),o.stencil.setLocked(!0),this.clear&&(this.renderToScreen?u.render(e,null):(u.render(e,t),u.render(e,n))),this.renderToScreen?(e.setRenderTarget(null),e.render(s,l)):(e.setRenderTarget(t),e.render(s,l),e.setRenderTarget(n),e.render(s,l)),o.color.setLocked(!1),o.depth.setLocked(!1),o.stencil.setLocked(!1),o.stencil.setFunc(a.EQUAL,1,4294967295),o.stencil.setOp(a.KEEP,a.KEEP,a.KEEP),o.stencil.setLocked(!0)}}]),n}(ne),Be=function(e){(0,s.Z)(n,e);var t=g(n);function n(e,r){var i,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},s=a.resolutionScale,l=void 0===s?1:s,u=a.width,f=void 0===u?oe.AUTO_SIZE:u,h=a.height,v=void 0===h?oe.AUTO_SIZE:h,g=a.renderTarget;(0,c.Z)(this,n),(i=t.call(this,"NormalPass")).needsSwap=!1,i.renderPass=new he(e,r,new d.MeshNormalMaterial);var A=i.renderPass.getClearPass();return A.overrideClearColor=new d.Color(7829503),A.overrideClearAlpha=1,i.renderTarget=g,void 0===i.renderTarget&&(i.renderTarget=new d.WebGLRenderTarget(1,1,{minFilter:d.NearestFilter,magFilter:d.NearestFilter,format:d.RGBFormat,stencilBuffer:!1}),i.renderTarget.texture.name="NormalPass.Target"),i.resolution=new oe((0,o.Z)(i),f,v,l),i}return(0,f.Z)(n,[{key:"texture",get:function(){return this.renderTarget.texture}},{key:"getResolutionScale",value:function(){return this.resolutionScale}},{key:"setResolutionScale",value:function(e){this.resolutionScale=e,this.setSize(this.resolution.base.x,this.resolution.base.y)}},{key:"render",value:function(e,t,n,r,i){var a=this.renderToScreen?null:this.renderTarget;this.renderPass.render(e,a,a)}},{key:"setSize",value:function(e,t){var n=this.resolution;n.base.set(e,t),this.renderTarget.setSize(n.width,n.height)}}]),n}(ne),Te=function(e){(0,s.Z)(n,e);var t=g(n);function n(e){var r,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"inputBuffer";return(0,c.Z)(this,n),(r=t.call(this,"ShaderPass")).setFullscreenMaterial(e),r.uniform=null,r.setInput(i),r}return(0,f.Z)(n,[{key:"setInput",value:function(e){var t=this.getFullscreenMaterial();if(this.uniform=null,null!==t){var n=t.uniforms;void 0!==n&&void 0!==n[e]&&(this.uniform=n[e])}}},{key:"render",value:function(e,t,n,r,i){null!==this.uniform&&null!==t&&(this.uniform.value=t.texture),e.setRenderTarget(this.renderToScreen?null:n),e.render(this.scene,this.camera)}}]),n}(ne),Me=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=n.depthBuffer,i=void 0===r||r,a=n.stencilBuffer,o=void 0!==a&&a,s=n.multisampling,l=void 0===s?0:s,u=n.frameBufferType;(0,c.Z)(this,e),this.renderer=t,this.inputBuffer=null,this.outputBuffer=null,null!==this.renderer&&(this.renderer.autoClear=!1,this.inputBuffer=this.createBuffer(i,o,u,l),this.outputBuffer=this.inputBuffer.clone(),this.enableExtensions()),this.copyPass=new Te(new b),this.depthTexture=null,this.passes=[],this.autoRenderToScreen=!0}return(0,f.Z)(e,[{key:"multisampling",get:function(){return this.inputBuffer instanceof d.WebGLMultisampleRenderTarget?this.inputBuffer.samples:0},set:function(e){var t=this.inputBuffer,n=this.multisampling;n>0&&e>0?(this.inputBuffer.samples=e,this.outputBuffer.samples=e):n!==e&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(t.depthBuffer,t.stencilBuffer,t.texture.type,e),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}},{key:"getRenderer",value:function(){return this.renderer}},{key:"enableExtensions",value:function(){var e=this.inputBuffer.texture.type,t=this.renderer.capabilities,n=this.renderer.getContext();e!==d.UnsignedByteType&&(t.isWebGL2?n.getExtension("EXT_color_buffer_float"):n.getExtension("EXT_color_buffer_half_float"))}},{key:"replaceRenderer",value:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=this.renderer;if(null!==n&&n!==e){var r=n.getSize(new d.Vector2),i=e.getSize(new d.Vector2),a=n.domElement.parentNode;this.renderer=e,this.renderer.autoClear=!1,r.equals(i)||this.setSize(),t&&null!==a&&(a.removeChild(n.domElement),a.appendChild(e.domElement)),this.enableExtensions()}return n}},{key:"createDepthTexture",value:function(){var e=this.depthTexture=new d.DepthTexture;return this.inputBuffer.depthTexture=e,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(e.format=d.DepthStencilFormat,e.type=d.UnsignedInt248Type):e.type=d.UnsignedIntType,e}},{key:"deleteDepthTexture",value:function(){if(null!==this.depthTexture){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();var e,t=h(this.passes);try{for(t.s();!(e=t.n()).done;){e.value.setDepthTexture(null)}}catch(n){t.e(n)}finally{t.f()}}}},{key:"createBuffer",value:function(e,t,n,r){var i=this.renderer.getDrawingBufferSize(new d.Vector2),a={format:this.renderer.getContext().getContextAttributes().alpha||n!==d.UnsignedByteType?d.RGBAFormat:d.RGBFormat,minFilter:d.LinearFilter,magFilter:d.LinearFilter,stencilBuffer:t,depthBuffer:e,type:n},o=r>0?new d.WebGLMultisampleRenderTarget(i.width,i.height,a):new d.WebGLRenderTarget(i.width,i.height,a);return r>0&&(o.samples=r),o.texture.name="EffectComposer.Buffer",o.texture.generateMipmaps=!1,o}},{key:"addPass",value:function(e,t){var n=this.passes,r=this.renderer,i=r.getDrawingBufferSize(new d.Vector2),a=r.getContext().getContextAttributes().alpha,o=this.inputBuffer.texture.type;if(e.setSize(i.width,i.height),e.initialize(r,a,o),this.autoRenderToScreen&&(n.length>0&&(n[n.length-1].renderToScreen=!1),e.renderToScreen&&(this.autoRenderToScreen=!1)),void 0!==t?n.splice(t,0,e):n.push(e),this.autoRenderToScreen&&(n[n.length-1].renderToScreen=!0),e.needsDepthTexture||null!==this.depthTexture)if(null===this.depthTexture){var s,l=this.createDepthTexture(),u=h(n);try{for(u.s();!(s=u.n()).done;)(e=s.value).setDepthTexture(l)}catch(c){u.e(c)}finally{u.f()}}else e.setDepthTexture(this.depthTexture)}},{key:"removePass",value:function(e){var t=this.passes,n=t.indexOf(e);if(-1!==n&&t.splice(n,1).length>0){if(null!==this.depthTexture){t.reduce((function(e,t){return e||t.needsDepthTexture}),!1)||(e.getDepthTexture()===this.depthTexture&&e.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&n===t.length&&(e.renderToScreen=!1,t.length>0&&(t[t.length-1].renderToScreen=!0))}}},{key:"removeAllPasses",value:function(){var e=this.passes;this.deleteDepthTexture(),e.length>0&&(this.autoRenderToScreen&&(e[e.length-1].renderToScreen=!1),this.passes=[])}},{key:"render",value:function(e){var t,n,r,i,a=this.renderer,o=this.copyPass,s=this.inputBuffer,l=this.outputBuffer,u=!1,c=h(this.passes);try{for(c.s();!(i=c.n()).done;){var f=i.value;f.enabled&&(f.render(a,s,l,e,u),f.needsSwap&&(u&&(o.renderToScreen=f.renderToScreen,t=a.getContext(),(n=a.state.buffers.stencil).setFunc(t.NOTEQUAL,1,4294967295),o.render(a,s,l,e,u),n.setFunc(t.EQUAL,1,4294967295)),r=s,s=l,l=r),f instanceof Ee?u=!0:f instanceof le&&(u=!1))}}catch(d){c.e(d)}finally{c.f()}}},{key:"setSize",value:function(e,t,n){var r=this.renderer;if(void 0===e||void 0===t){var i=r.getSize(new d.Vector2);e=i.width,t=i.height}else r.setSize(e,t,n);var a=r.getDrawingBufferSize(new d.Vector2);this.inputBuffer.setSize(a.width,a.height),this.outputBuffer.setSize(a.width,a.height);var o,s=h(this.passes);try{for(s.s();!(o=s.n()).done;){o.value.setSize(a.width,a.height)}}catch(l){s.e(l)}finally{s.f()}}},{key:"reset",value:function(){this.dispose(),this.autoRenderToScreen=!0}},{key:"dispose",value:function(){var e,t=h(this.passes);try{for(t.s();!(e=t.n()).done;){e.value.dispose()}}catch(n){t.e(n)}finally{t.f()}this.passes=[],null!==this.inputBuffer&&this.inputBuffer.dispose(),null!==this.outputBuffer&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose()}}]),e}(),Se=function(e){(0,s.Z)(n,e);var t=g(n);function n(e){var r,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;return(0,c.Z)(this,n),(r=t.call(this)).currentLayer=i,void 0!==e&&r.set(e),r}return(0,f.Z)(n,[{key:"layer",get:function(){return this.currentLayer},set:function(e){var t,n=this.currentLayer,r=h(this);try{for(r.s();!(t=r.n()).done;){var i=t.value;i.layers.disable(n),i.layers.enable(e)}}catch(a){r.e(a)}finally{r.f()}this.currentLayer=e}},{key:"clear",value:function(){var e,t=this.layer,r=h(this);try{for(r.s();!(e=r.n()).done;){e.value.layers.disable(t)}}catch(i){r.e(i)}finally{r.f()}return(0,a.Z)((0,u.Z)(n.prototype),"clear",this).call(this)}},{key:"set",value:function(e){this.clear();var t,n=h(e);try{for(n.s();!(t=n.n()).done;){var r=t.value;this.add(r)}}catch(i){n.e(i)}finally{n.f()}return this}},{key:"indexOf",value:function(e){return this.has(e)?0:-1}},{key:"add",value:function(e){return e.layers.enable(this.layer),(0,a.Z)((0,u.Z)(n.prototype),"add",this).call(this,e),this}},{key:"delete",value:function(e){return this.has(e)&&e.layers.disable(this.layer),(0,a.Z)((0,u.Z)(n.prototype),"delete",this).call(this,e)}},{key:"setVisible",value:function(e){var t,n=h(this);try{for(n.s();!(t=n.n()).done;){var r=t.value;e?r.layers.enable(0):r.layers.disable(0)}}catch(i){n.e(i)}finally{n.f()}return this}}]),n}((0,r.Z)(Set)),Pe="uniform sampler2D texture;\r\nuniform float intensity;\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\toutputColor = clamp(texture2D(texture, uv) * intensity, 0.0, 1.0);\r\n\r\n}\r\n",Ie=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=r.blendFunction,a=void 0===i?ge.SCREEN:i,s=r.luminanceThreshold,l=void 0===s?.9:s,u=r.luminanceSmoothing,f=void 0===u?.025:u,h=r.resolutionScale,v=void 0===h?.5:h,g=r.intensity,A=void 0===g?1:g,m=r.width,p=void 0===m?oe.AUTO_SIZE:m,y=r.height,x=void 0===y?oe.AUTO_SIZE:y,w=r.kernelSize,C=void 0===w?F.LARGE:w;return(0,c.Z)(this,n),(e=t.call(this,"BloomEffect",Pe,{blendFunction:a,uniforms:new Map([["texture",new d.Uniform(null)],["intensity",new d.Uniform(A)]])})).renderTarget=new d.WebGLRenderTarget(1,1,{minFilter:d.LinearFilter,magFilter:d.LinearFilter,stencilBuffer:!1,depthBuffer:!1}),e.renderTarget.texture.name="Bloom.Target",e.renderTarget.texture.generateMipmaps=!1,e.uniforms.get("texture").value=e.renderTarget.texture,e.blurPass=new se({resolutionScale:v,width:p,height:x,kernelSize:C}),e.blurPass.resolution.resizable=(0,o.Z)(e),e.luminancePass=new Te(new Z(!0)),e.luminanceMaterial.threshold=l,e.luminanceMaterial.smoothing=f,e}return(0,f.Z)(n,[{key:"texture",get:function(){return this.renderTarget.texture}},{key:"luminanceMaterial",get:function(){return this.luminancePass.getFullscreenMaterial()}},{key:"resolution",get:function(){return this.blurPass.resolution}},{key:"width",get:function(){return this.resolution.width},set:function(e){this.resolution.width=e}},{key:"height",get:function(){return this.resolution.height},set:function(e){this.resolution.height=e}},{key:"dithering",get:function(){return this.blurPass.dithering},set:function(e){this.blurPass.dithering=e}},{key:"kernelSize",get:function(){return this.blurPass.kernelSize},set:function(e){this.blurPass.kernelSize=e}},{key:"distinction",get:function(){return console.warn(this.name,"The distinction field has been removed, use luminanceMaterial.threshold and luminanceMaterial.smoothing instead."),1},set:function(e){console.warn(this.name,"The distinction field has been removed, use luminanceMaterial.threshold and luminanceMaterial.smoothing instead.")}},{key:"intensity",get:function(){return this.uniforms.get("intensity").value},set:function(e){this.uniforms.get("intensity").value=e}},{key:"getResolutionScale",value:function(){return this.resolution.scale}},{key:"setResolutionScale",value:function(e){this.resolution.scale=e}},{key:"update",value:function(e,t,n){var r=this.renderTarget;this.luminancePass.enabled?(this.luminancePass.render(e,t,r),this.blurPass.render(e,r,r)):this.blurPass.render(e,t,r)}},{key:"setSize",value:function(e,t){this.blurPass.setSize(e,t),this.renderTarget.setSize(this.resolution.width,this.resolution.height)}},{key:"initialize",value:function(e,t,n){this.blurPass.initialize(e,t,n),t||n!==d.UnsignedByteType||(this.renderTarget.texture.format=d.RGBFormat),void 0!==n&&(this.renderTarget.texture.type=n)}}]),n}(pe),Fe="uniform float brightness;\r\nuniform float contrast;\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\tvec3 color = inputColor.rgb + vec3(brightness - 0.5);\r\n\r\n\tif(contrast > 0.0) {\r\n\r\n\t\tcolor /= vec3(1.0 - contrast);\r\n\r\n\t} else {\r\n\r\n\t\tcolor *= vec3(1.0 + contrast);\r\n\r\n\t}\r\n\r\n\toutputColor = vec4(min(color + vec3(0.5), 1.0), inputColor.a);\r\n\r\n}\r\n",be=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.blendFunction,i=void 0===r?ge.NORMAL:r,a=e.brightness,o=void 0===a?0:a,s=e.contrast,l=void 0===s?0:s;return(0,c.Z)(this,n),t.call(this,"BrightnessContrastEffect",Fe,{blendFunction:i,uniforms:new Map([["brightness",new d.Uniform(o)],["contrast",new d.Uniform(l)]])})}return(0,f.Z)(n)}(pe),Re="void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\tfloat sum = inputColor.r + inputColor.g + inputColor.b;\r\n\r\n\toutputColor = vec4(vec3(sum / 3.0), inputColor.a);\r\n\r\n}\r\n",ke=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:ge.NORMAL;return(0,c.Z)(this,n),t.call(this,"ColorAverageEffect",Re,{blendFunction:e})}return(0,f.Z)(n)}(pe),Ue="uniform float factor;\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\toutputColor = vec4(floor(inputColor.rgb * factor + 0.5) / factor, inputColor.a);\r\n\r\n}\r\n",Le=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=r.blendFunction,a=void 0===i?ge.NORMAL:i,o=r.bits,s=void 0===o?16:o;return(0,c.Z)(this,n),(e=t.call(this,"ColorDepthEffect",Ue,{blendFunction:a,uniforms:new Map([["factor",new d.Uniform(1)]])})).bits=0,e.setBitDepth(s),e}return(0,f.Z)(n,[{key:"getBitDepth",value:function(){return this.bits}},{key:"setBitDepth",value:function(e){this.bits=e,this.uniforms.get("factor").value=Math.pow(2,e/3)}}]),n}(pe),Oe="varying vec2 vUvR;\r\nvarying vec2 vUvB;\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\tvec4 color = inputColor;\r\n\r\n\t#ifdef ALPHA\r\n\r\n\t\tvec2 ra = texture2D(inputBuffer, vUvR).ra;\r\n\t\tvec2 ba = texture2D(inputBuffer, vUvB).ba;\r\n\r\n\t\tcolor.r = ra.x;\r\n\t\tcolor.b = ba.x;\r\n\t\tcolor.a = max(max(ra.y, ba.y), inputColor.a);\r\n\r\n\t#else\r\n\r\n\t\tcolor.r = texture2D(inputBuffer, vUvR).r;\r\n\t\tcolor.b = texture2D(inputBuffer, vUvB).b;\r\n\r\n\t#endif\r\n\r\n\toutputColor = color;\r\n\r\n}\r\n",Ge="uniform vec2 offset;\r\n\r\nvarying vec2 vUvR;\r\nvarying vec2 vUvB;\r\n\r\nvoid mainSupport(const in vec2 uv) {\r\n\r\n\tvUvR = uv + offset;\r\n\tvUvB = uv - offset;\r\n\r\n}\r\n",Ne=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.blendFunction,i=void 0===r?ge.NORMAL:r,a=e.offset,o=void 0===a?new d.Vector2(.001,5e-4):a;return(0,c.Z)(this,n),t.call(this,"ChromaticAberrationEffect",Oe,{vertexShader:Ge,blendFunction:i,attributes:ye.CONVOLUTION,uniforms:new Map([["offset",new d.Uniform(o)]])})}return(0,f.Z)(n,[{key:"offset",get:function(){return this.uniforms.get("offset").value},set:function(e){this.uniforms.get("offset").value=e}},{key:"initialize",value:function(e,t,n){t?this.defines.set("ALPHA","1"):this.defines.delete("ALPHA")}}]),n}(pe),He="void mainImage(const in vec4 inputColor, const in vec2 uv, const in float depth, out vec4 outputColor) {\r\n\r\n\t#ifdef INVERTED\r\n\r\n\t\tvec3 color = vec3(1.0 - depth);\r\n\r\n\t#else\r\n\r\n\t\tvec3 color = vec3(depth);\r\n\r\n\t#endif\r\n\r\n\toutputColor = vec4(color, inputColor.a);\r\n\r\n}\r\n",ze=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=r.blendFunction,a=void 0===i?ge.NORMAL:i,o=r.inverted,s=void 0!==o&&o;return(0,c.Z)(this,n),(e=t.call(this,"DepthEffect",He,{blendFunction:a,attributes:ye.DEPTH})).inverted=s,e}return(0,f.Z)(n,[{key:"inverted",get:function(){return this.defines.has("INVERTED")},set:function(e){this.inverted!==e&&(e?this.defines.set("INVERTED","1"):this.defines.delete("INVERTED"),this.setChanged())}}]),n}(pe),Qe="uniform sampler2D nearColorBuffer;\r\nuniform sampler2D farColorBuffer;\r\nuniform sampler2D nearCoCBuffer;\r\n\r\nuniform float scale;\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, const in float depth, out vec4 outputColor) {\r\n\r\n\tvec4 colorNear = texture2D(nearColorBuffer, uv);\r\n\tvec4 colorFar = texture2D(farColorBuffer, uv);\r\n\r\n\tfloat CoCNear = texture2D(nearCoCBuffer, uv).r;\r\n\tCoCNear = min(CoCNear * scale, 1.0);\r\n\r\n\t// The far color buffer has been premultiplied with the CoC buffer.\r\n\tvec4 result = inputColor * (1.0 - colorFar.a) + colorFar;\r\n\tresult = mix(result, colorNear, CoCNear);\r\n\r\n\toutputColor = result;\r\n\r\n}\r\n",Ze=function(e){(0,s.Z)(n,e);var t=g(n);function n(e){var r,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=i.blendFunction,s=void 0===a?ge.NORMAL:a,l=i.focusDistance,u=void 0===l?0:l,f=i.focalLength,h=void 0===f?.1:f,v=i.bokehScale,g=void 0===v?1:v,A=i.width,p=void 0===A?oe.AUTO_SIZE:A,y=i.height,x=void 0===y?oe.AUTO_SIZE:y;(0,c.Z)(this,n),(r=t.call(this,"DepthOfFieldEffect",Qe,{blendFunction:s,attributes:ye.DEPTH,uniforms:new Map([["nearColorBuffer",new d.Uniform(null)],["farColorBuffer",new d.Uniform(null)],["nearCoCBuffer",new d.Uniform(null)],["scale",new d.Uniform(1)]])})).camera=e,r.renderTarget=new d.WebGLRenderTarget(1,1,{minFilter:d.LinearFilter,magFilter:d.LinearFilter,stencilBuffer:!1,depthBuffer:!1}),r.renderTarget.texture.name="DoF.Intermediate",r.renderTarget.texture.generateMipmaps=!1,r.renderTargetMasked=r.renderTarget.clone(),r.renderTargetMasked.texture.name="DoF.Masked.Far",r.renderTargetNear=r.renderTarget.clone(),r.renderTargetNear.texture.name="DoF.Bokeh.Near",r.uniforms.get("nearColorBuffer").value=r.renderTargetNear.texture,r.renderTargetFar=r.renderTarget.clone(),r.renderTargetFar.texture.name="DoF.Bokeh.Far",r.uniforms.get("farColorBuffer").value=r.renderTargetFar.texture,r.renderTargetCoC=r.renderTarget.clone(),r.renderTargetCoC.texture.format=d.RGBFormat,r.renderTargetCoC.texture.name="DoF.CoC",r.renderTargetCoCBlurred=r.renderTargetCoC.clone(),r.renderTargetCoCBlurred.texture.name="DoF.CoC.Blurred",r.uniforms.get("nearCoCBuffer").value=r.renderTargetCoCBlurred.texture,r.cocPass=new Te(new E(e));var w=r.circleOfConfusionMaterial;w.uniforms.focusDistance.value=u,w.uniforms.focalLength.value=h,r.blurPass=new se({width:p,height:x,kernelSize:F.MEDIUM}),r.blurPass.resolution.resizable=(0,o.Z)(r),r.maskPass=new Te(new Y(r.renderTargetCoC.texture));var C=r.maskPass.getFullscreenMaterial();return C.maskFunction=X.MULTIPLY_RGB_SET_ALPHA,C.colorChannel=m,r.bokehNearBasePass=new Te(new D(!1,!0)),r.bokehNearFillPass=new Te(new D(!0,!0)),r.bokehFarBasePass=new Te(new D(!1,!1)),r.bokehFarFillPass=new Te(new D(!0,!1)),r.bokehScale=g,r.target=null,r}return(0,f.Z)(n,[{key:"circleOfConfusionMaterial",get:function(){return this.cocPass.getFullscreenMaterial()}},{key:"resolution",get:function(){return this.blurPass.resolution}},{key:"bokehScale",get:function(){return this.uniforms.get("scale").value},set:function(e){[this.bokehNearBasePass,this.bokehNearFillPass,this.bokehFarBasePass,this.bokehFarFillPass].map((function(e){return e.getFullscreenMaterial().uniforms.scale})).forEach((function(t){t.value=e})),this.maskPass.getFullscreenMaterial().uniforms.strength.value=e,this.uniforms.get("scale").value=e}},{key:"calculateFocusDistance",value:function(e){var t=this.camera,n=t.far-t.near,r=t.position.distanceTo(e);return Math.min(Math.max(r/n,0),1)}},{key:"setDepthTexture",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=this.circleOfConfusionMaterial;n.uniforms.depthBuffer.value=e,n.depthPacking=t}},{key:"update",value:function(e,t,n){var r=this.renderTarget,i=this.renderTargetCoC,a=this.renderTargetCoCBlurred,o=this.renderTargetMasked,s=this.bokehFarBasePass,l=this.bokehFarFillPass,u=s.getFullscreenMaterial().uniforms,c=l.getFullscreenMaterial().uniforms,f=this.bokehNearBasePass,d=this.bokehNearFillPass,h=f.getFullscreenMaterial().uniforms,v=d.getFullscreenMaterial().uniforms;if(null!==this.target){var g=this.calculateFocusDistance(this.target);this.circleOfConfusionMaterial.uniforms.focusDistance.value=g}this.cocPass.render(e,null,i),this.blurPass.render(e,i,a),this.maskPass.render(e,t,o),u.cocBuffer.value=c.cocBuffer.value=i.texture,s.render(e,o,r),l.render(e,r,this.renderTargetFar),h.cocBuffer.value=v.cocBuffer.value=a.texture,f.render(e,t,r),d.render(e,r,this.renderTargetNear)}},{key:"setSize",value:function(e,t){var n=this.resolution,r=[this.cocPass,this.blurPass,this.maskPass,this.bokehNearBasePass,this.bokehNearFillPass,this.bokehFarBasePass,this.bokehFarFillPass];r.push(this.renderTargetCoC,this.renderTargetMasked),r.forEach((function(n){return n.setSize(e,t)}));var i=n.width,a=n.height;(r=[this.renderTarget,this.renderTargetNear,this.renderTargetFar,this.renderTargetCoCBlurred]).forEach((function(e){return e.setSize(i,a)})),[this.bokehNearBasePass,this.bokehNearFillPass,this.bokehFarBasePass,this.bokehFarFillPass].forEach((function(e){return e.getFullscreenMaterial().setTexelSize(1/i,1/a)}))}},{key:"initialize",value:function(e,t,n){[this.cocPass,this.maskPass,this.bokehNearBasePass,this.bokehNearFillPass,this.bokehFarBasePass,this.bokehFarFillPass].forEach((function(r){return r.initialize(e,t,n)})),this.blurPass.initialize(e,t,d.UnsignedByteType),t||n!==d.UnsignedByteType||(this.renderTargetNear.texture.type=d.RGBFormat),void 0!==n&&(this.renderTarget.texture.type=n,this.renderTargetNear.texture.type=n,this.renderTargetFar.texture.type=n,this.renderTargetMasked.texture.type=n)}}]),n}(pe),Ve="uniform vec2 angle;\r\nuniform float scale;\r\n\r\nfloat pattern(const in vec2 uv) {\r\n\r\n\tvec2 point = scale * vec2(\r\n\t\tdot(angle.yx, vec2(uv.x, -uv.y)),\r\n\t\tdot(angle, uv)\r\n\t);\r\n\r\n\treturn (sin(point.x) * sin(point.y)) * 4.0;\r\n\r\n}\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\tvec3 color = vec3(inputColor.rgb * 10.0 - 5.0 + pattern(uv * resolution));\r\n\toutputColor = vec4(color, inputColor.a);\r\n\r\n}\r\n",Ye=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=r.blendFunction,a=void 0===i?ge.NORMAL:i,o=r.angle,s=void 0===o?.5*Math.PI:o,l=r.scale,u=void 0===l?1:l;return(0,c.Z)(this,n),(e=t.call(this,"DotScreenEffect",Ve,{blendFunction:a,uniforms:new Map([["angle",new d.Uniform(new d.Vector2)],["scale",new d.Uniform(u)]])})).setAngle(s),e}return(0,f.Z)(n,[{key:"setAngle",value:function(e){this.uniforms.get("angle").value.set(Math.sin(e),Math.cos(e))}}]),n}(pe);function Xe(e,t,n){var r,i=new Map([[d.LuminanceFormat,1],[d.RedFormat,1],[d.RGFormat,2],[d.RGBFormat,3],[d.RGBAFormat,4]]);if(i.has(t)||console.error("Invalid noise texture format"),n===d.UnsignedByteType)for(var a=0,o=(r=new Uint8Array(e*i.get(t))).length;a<o;++a)r[a]=255*Math.random();else for(var s=0,l=(r=new Float32Array(e*i.get(t))).length;s<l;++s)r[s]=Math.random();return r}var We=function(e){(0,s.Z)(n,e);var t=g(n);function n(e,r){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:d.LuminanceFormat,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:d.UnsignedByteType;return(0,c.Z)(this,n),t.call(this,Xe(e*r,i,a),e,r,i,a)}return(0,f.Z)(n)}(d.DataTexture),Ke="uniform sampler2D perturbationMap;\r\n\r\nuniform bool active;\r\nuniform float columns;\r\nuniform float random;\r\nuniform vec2 seed;\r\nuniform vec2 distortion;\r\n\r\nvoid mainUv(inout vec2 uv) {\r\n\r\n\tif(active) {\r\n\r\n\t\tif(uv.y < distortion.x + columns && uv.y > distortion.x - columns * random) {\r\n\r\n\t\t\tfloat sx = clamp(ceil(seed.x), 0.0, 1.0);\r\n\t\t\tuv.y = sx * (1.0 - (uv.y + distortion.y)) + (1.0 - sx) * distortion.y;\r\n\r\n\t\t}\r\n\r\n\t\tif(uv.x < distortion.y + columns && uv.x > distortion.y - columns * random) {\r\n\r\n\t\t\tfloat sy = clamp(ceil(seed.y), 0.0, 1.0);\r\n\t\t\tuv.x = sy * distortion.x + (1.0 - sy) * (1.0 - (uv.x + distortion.x));\r\n\r\n\t\t}\r\n\r\n\t\tvec2 normal = texture2D(perturbationMap, uv * random * random).rg;\r\n\t\tuv += normal * seed * (random * 0.2);\r\n\r\n\t}\r\n\r\n}\r\n",je="Glitch.Generated";function Je(e,t){return e+Math.random()*(t-e)}var qe=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=r.blendFunction,a=void 0===i?ge.NORMAL:i,o=r.chromaticAberrationOffset,s=void 0===o?null:o,l=r.delay,u=void 0===l?new d.Vector2(1.5,3.5):l,f=r.duration,h=void 0===f?new d.Vector2(.6,1):f,v=r.strength,g=void 0===v?new d.Vector2(.3,1):v,A=r.columns,m=void 0===A?.05:A,p=r.ratio,y=void 0===p?.85:p,x=r.perturbationMap,w=void 0===x?null:x,C=r.dtSize,D=void 0===C?64:C;return(0,c.Z)(this,n),(e=t.call(this,"GlitchEffect",Ke,{blendFunction:a,uniforms:new Map([["perturbationMap",new d.Uniform(null)],["columns",new d.Uniform(m)],["active",new d.Uniform(!1)],["random",new d.Uniform(1)],["seed",new d.Uniform(new d.Vector2)],["distortion",new d.Uniform(new d.Vector2)]])})).setPerturbationMap(null===w?e.generatePerturbationMap(D):w),e.delay=u,e.duration=h,e.breakPoint=new d.Vector2(Je(e.delay.x,e.delay.y),Je(e.duration.x,e.duration.y)),e.time=0,e.seed=e.uniforms.get("seed").value,e.distortion=e.uniforms.get("distortion").value,e.mode=_e.SPORADIC,e.strength=g,e.ratio=y,e.chromaticAberrationOffset=s,e}return(0,f.Z)(n,[{key:"active",get:function(){return this.uniforms.get("active").value}},{key:"getPerturbationMap",value:function(){return this.uniforms.get("perturbationMap").value}},{key:"setPerturbationMap",value:function(e){var t=this.getPerturbationMap();null!==t&&t.name===je&&t.dispose(),e.minFilter=e.magFilter=d.NearestFilter,e.wrapS=e.wrapT=d.RepeatWrapping,e.generateMipmaps=!1,this.uniforms.get("perturbationMap").value=e}},{key:"generatePerturbationMap",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:64,t=new We(e,e,d.RGBFormat);return t.name=je,t}},{key:"update",value:function(e,t,n){var r,i=this.mode,a=this.breakPoint,o=this.chromaticAberrationOffset,s=this.strength,l=this.time,u=!1,c=0,f=0;i!==_e.DISABLED&&(i===_e.SPORADIC&&(r=(l+=n)>a.x,l>=a.x+a.y&&(a.set(Je(this.delay.x,this.delay.y),Je(this.duration.x,this.duration.y)),l=0)),c=Math.random(),this.uniforms.get("random").value=c,r&&c>this.ratio||i===_e.CONSTANT_WILD?(u=!0,c*=.03*s.y,f=Je(-Math.PI,Math.PI),this.seed.set(Je(-s.y,s.y),Je(-s.y,s.y)),this.distortion.set(Je(0,1),Je(0,1))):(r||i===_e.CONSTANT_MILD)&&(u=!0,c*=.03*s.x,f=Je(-Math.PI,Math.PI),this.seed.set(Je(-s.x,s.x),Je(-s.x,s.x)),this.distortion.set(Je(0,1),Je(0,1))),this.time=l),null!==o&&(u?o.set(Math.cos(f),Math.sin(f)).multiplyScalar(c):o.set(0,0)),this.uniforms.get("active").value=u}}]),n}(pe),_e={DISABLED:0,SPORADIC:1,CONSTANT_MILD:2,CONSTANT_WILD:3},$e="uniform sampler2D texture;\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\toutputColor = texture2D(texture, uv);\r\n\r\n}\r\n",et=new d.Vector3,tt=new d.Matrix4,nt=function(e){(0,s.Z)(n,e);var t=g(n);function n(e,r){var i,a,s,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},u=l.blendFunction,f=void 0===u?ge.SCREEN:u,h=l.samples,v=void 0===h?60:h,g=l.density,A=void 0===g?.96:g,m=l.decay,p=void 0===m?.9:m,y=l.weight,x=void 0===y?.4:y,w=l.exposure,C=void 0===w?.6:w,D=l.clampMax,E=void 0===D?1:D,B=l.resolutionScale,T=void 0===B?.5:B,M=l.width,S=void 0===M?oe.AUTO_SIZE:M,P=l.height,I=void 0===P?oe.AUTO_SIZE:P,b=l.kernelSize,R=void 0===b?F.SMALL:b,k=l.blur,U=void 0===k||k;return(0,c.Z)(this,n),(i=t.call(this,"GodRaysEffect",$e,{blendFunction:f,attributes:ye.DEPTH,uniforms:new Map([["texture",new d.Uniform(null)]])})).camera=e,i.lightSource=r,i.lightSource.material.depthWrite=!1,i.lightSource.material.transparent=!0,i.lightScene=new d.Scene,i.screenPosition=new d.Vector2,i.renderTargetA=new d.WebGLRenderTarget(1,1,{minFilter:d.LinearFilter,magFilter:d.LinearFilter,stencilBuffer:!1,depthBuffer:!1}),i.renderTargetA.texture.name="GodRays.Target.A",i.renderTargetB=i.renderTargetA.clone(),i.renderTargetB.texture.name="GodRays.Target.B",i.uniforms.get("texture").value=i.renderTargetB.texture,i.renderTargetLight=i.renderTargetA.clone(),i.renderTargetLight.texture.name="GodRays.Light",i.renderTargetLight.depthBuffer=!0,i.renderTargetLight.depthTexture=new d.DepthTexture,i.renderPassLight=new he(i.lightScene,e),i.renderPassLight.getClearPass().overrideClearColor=new d.Color(0),i.clearPass=new ce(!0,!1,!1),i.clearPass.overrideClearColor=new d.Color(0),i.blurPass=new se({resolutionScale:T,width:S,height:I,kernelSize:R}),i.blurPass.resolution.resizable=(0,o.Z)(i),i.depthMaskPass=new Te((a=i.renderTargetLight.depthTexture,(s=new L).uniforms.depthBuffer1.value=a,s)),i.godRaysPass=new Te(function(){var e=new z(i.screenPosition);return e.uniforms.density.value=A,e.uniforms.decay.value=p,e.uniforms.weight.value=x,e.uniforms.exposure.value=C,e.uniforms.clampMax.value=E,e}()),i.samples=v,i.blur=U,i}return(0,f.Z)(n,[{key:"texture",get:function(){return this.renderTargetB.texture}},{key:"godRaysMaterial",get:function(){return this.godRaysPass.getFullscreenMaterial()}},{key:"resolution",get:function(){return this.blurPass.resolution}},{key:"width",get:function(){return this.resolution.width},set:function(e){this.resolution.width=e}},{key:"height",get:function(){return this.resolution.height},set:function(e){this.resolution.height=e}},{key:"dithering",get:function(){return this.godRaysMaterial.dithering},set:function(e){var t=this.godRaysMaterial;t.dithering=e,t.needsUpdate=!0}},{key:"blur",get:function(){return this.blurPass.enabled},set:function(e){this.blurPass.enabled=e}},{key:"kernelSize",get:function(){return this.blurPass.kernelSize},set:function(e){this.blurPass.kernelSize=e}},{key:"getResolutionScale",value:function(){return this.resolution.scale}},{key:"setResolutionScale",value:function(e){this.resolution.scale=e}},{key:"samples",get:function(){return this.godRaysMaterial.samples},set:function(e){this.godRaysMaterial.samples=e}},{key:"setDepthTexture",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=this.depthMaskPass.getFullscreenMaterial();n.uniforms.depthBuffer0.value=e,n.defines.DEPTH_PACKING_0=t.toFixed(0)}},{key:"update",value:function(e,t,n){var r=this.lightSource,i=r.parent,a=r.matrixAutoUpdate,o=this.renderTargetA,s=this.renderTargetLight;r.material.depthWrite=!0,r.matrixAutoUpdate=!1,r.updateWorldMatrix(!0,!1),null!==i&&(a||tt.copy(r.matrix),r.matrix.copy(r.matrixWorld)),this.lightScene.add(r),this.renderPassLight.render(e,s),this.clearPass.render(e,o),this.depthMaskPass.render(e,s,o),r.material.depthWrite=!1,r.matrixAutoUpdate=a,null!==i&&(a||r.matrix.copy(tt),i.add(r)),et.setFromMatrixPosition(r.matrixWorld).project(this.camera),this.screenPosition.set(Math.min(Math.max(.5*(et.x+1),-1),2),Math.min(Math.max(.5*(et.y+1),-1),2)),this.blur&&this.blurPass.render(e,o,o),this.godRaysPass.render(e,o,this.renderTargetB)}},{key:"setSize",value:function(e,t){this.blurPass.setSize(e,t),this.renderPassLight.setSize(e,t),this.depthMaskPass.setSize(e,t),this.godRaysPass.setSize(e,t);var n=this.resolution.width,r=this.resolution.height;this.renderTargetA.setSize(n,r),this.renderTargetB.setSize(n,r),this.renderTargetLight.setSize(n,r)}},{key:"initialize",value:function(e,t,n){this.blurPass.initialize(e,t,n),this.renderPassLight.initialize(e,t,n),this.depthMaskPass.initialize(e,t,n),this.godRaysPass.initialize(e,t,n),t||n!==d.UnsignedByteType||(this.renderTargetA.texture.format=d.RGBFormat,this.renderTargetB.texture.format=d.RGBFormat,this.renderTargetLight.texture.format=d.RGBFormat),void 0!==n&&(this.renderTargetA.texture.type=n,this.renderTargetB.texture.type=n,this.renderTargetLight.texture.type=n)}}]),n}(pe),rt="uniform vec2 scale;\r\nuniform float lineWidth;\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\tfloat grid = 0.5 - max(abs(mod(uv.x * scale.x, 1.0) - 0.5), abs(mod(uv.y * scale.y, 1.0) - 0.5));\r\n\toutputColor = vec4(vec3(smoothstep(0.0, lineWidth, grid)), inputColor.a);\r\n\r\n}\r\n",it=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=r.blendFunction,a=void 0===i?ge.OVERLAY:i,o=r.scale,s=void 0===o?1:o,l=r.lineWidth,u=void 0===l?0:l;return(0,c.Z)(this,n),(e=t.call(this,"GridEffect",rt,{blendFunction:a,uniforms:new Map([["scale",new d.Uniform(new d.Vector2)],["lineWidth",new d.Uniform(u)]])})).resolution=new d.Vector2,e.scale=Math.max(s,1e-6),e.lineWidth=Math.max(u,0),e}return(0,f.Z)(n,[{key:"getScale",value:function(){return this.scale}},{key:"setScale",value:function(e){this.scale=e,this.setSize(this.resolution.x,this.resolution.y)}},{key:"getLineWidth",value:function(){return this.lineWidth}},{key:"setLineWidth",value:function(e){this.lineWidth=e,this.setSize(this.resolution.x,this.resolution.y)}},{key:"setSize",value:function(e,t){this.resolution.set(e,t);var n=e/t,r=this.scale*(.125*t);this.uniforms.get("scale").value.set(n*r,r),this.uniforms.get("lineWidth").value=r/t+this.lineWidth}}]),n}(pe),at="uniform vec3 hue;\r\nuniform float saturation;\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\t// Hue.\r\n\tvec3 color = vec3(\r\n\t\tdot(inputColor.rgb, hue.xyz),\r\n\t\tdot(inputColor.rgb, hue.zxy),\r\n\t\tdot(inputColor.rgb, hue.yzx)\r\n\t);\r\n\r\n\t// Saturation.\r\n\tfloat average = (color.r + color.g + color.b) / 3.0;\r\n\tvec3 diff = average - color;\r\n\r\n\tif(saturation > 0.0) {\r\n\r\n\t\tcolor += diff * (1.0 - 1.0 / (1.001 - saturation));\r\n\r\n\t} else {\r\n\r\n\t\tcolor += diff * -saturation;\r\n\r\n\t}\r\n\r\n\toutputColor = vec4(min(color, 1.0), inputColor.a);\r\n\r\n}\r\n",ot=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=r.blendFunction,a=void 0===i?ge.NORMAL:i,o=r.hue,s=void 0===o?0:o,l=r.saturation,u=void 0===l?0:l;return(0,c.Z)(this,n),(e=t.call(this,"HueSaturationEffect",at,{blendFunction:a,uniforms:new Map([["hue",new d.Uniform(new d.Vector3)],["saturation",new d.Uniform(u)]])})).setHue(s),e}return(0,f.Z)(n,[{key:"setHue",value:function(e){var t=Math.sin(e),n=Math.cos(e);this.uniforms.get("hue").value.set(2*n,-Math.sqrt(3)*t-n,Math.sqrt(3)*t-n).addScalar(1).divideScalar(3)}}]),n}(pe);function st(e,t,n){var r=document.createElementNS("http://www.w3.org/1999/xhtml","canvas"),i=r.getContext("2d");if(r.width=e,r.height=t,n instanceof Image)i.drawImage(n,0,0);else{var a=i.createImageData(e,t);a.data.set(n),i.putImageData(a,0,0)}return r}var lt=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;(0,c.Z)(this,e),this.width=t,this.height=n,this.data=r}return(0,f.Z)(e,[{key:"toCanvas",value:function(){return"undefined"==typeof document?null:st(this.width,this.height,this.data)}}],[{key:"from",value:function(t){var n,r=t.width,i=t.height;if(t instanceof Image){var a=st(r,i,t);if(null!==a)n=a.getContext("2d").getImageData(0,0,r,i).data}else n=t.data;return new e(r,i,n)}}]),e}(),ut="lut.scaleup",ct='(()=>{var q={SCALE_UP:"lut.scaleup"};var _=[new Float32Array(3),new Float32Array(3)],t=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],P=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function V(a,n,r,h){let i=r[0]-n[0],s=r[1]-n[1],c=r[2]-n[2],A=a[0]-n[0],F=a[1]-n[1],e=a[2]-n[2],l=s*e-c*F,w=c*A-i*e,f=i*F-s*A,y=Math.sqrt(l*l+w*w+f*f),m=y*.5,U=l/y,X=w/y,Y=f/y,p=-(a[0]*U+a[1]*X+a[2]*Y),u=h[0]*U+h[1]*X+h[2]*Y;return Math.abs(u+p)*m/3}function T(a,n,r,h,i,s){let c=(r+h*n+i*n*n)*3;s[0]=a[c+0],s[1]=a[c+1],s[2]=a[c+2]}function k(a,n,r,h,i,s){let c=r*(n-1),A=h*(n-1),F=i*(n-1),e=c%1,l=A%1,w=F%1,f=Math.floor(c),y=Math.floor(A),m=Math.floor(F),U=Math.ceil(c),X=Math.ceil(A),Y=Math.ceil(F);if(f===c&&y===A&&m===F)T(a,n,c,A,F,s);else{let p;e>=l&&l>=w?p=P[0]:e>=w&&w>=l?p=P[1]:w>=e&&e>=l?p=P[2]:l>=e&&e>=w?p=P[3]:l>=w&&w>=e?p=P[4]:w>=l&&l>=e&&(p=P[5]);let[u,M,x,d]=p,g=_[0];g[0]=e,g[1]=l,g[2]=w;let o=_[1],Z=U-f,b=X-y,L=Y-m;o[0]=Z*u[0]+f,o[1]=b*u[1]+y,o[2]=L*u[2]+m,T(a,n,o[0],o[1],o[2],t[0]),o[0]=Z*M[0]+f,o[1]=b*M[1]+y,o[2]=L*M[2]+m,T(a,n,o[0],o[1],o[2],t[1]),o[0]=Z*x[0]+f,o[1]=b*x[1]+y,o[2]=L*x[2]+m,T(a,n,o[0],o[1],o[2],t[2]),o[0]=Z*d[0]+f,o[1]=b*d[1]+y,o[2]=L*d[2]+m,T(a,n,o[0],o[1],o[2],t[3]);let v=V(M,x,d,g)*6,S=V(u,x,d,g)*6,C=V(u,M,d,g)*6,E=V(u,M,x,g)*6;t[0][0]*=v,t[0][1]*=v,t[0][2]*=v,t[1][0]*=S,t[1][1]*=S,t[1][2]*=S,t[2][0]*=C,t[2][1]*=C,t[2][2]*=C,t[3][0]*=E,t[3][1]*=E,t[3][2]*=E,s[0]=t[0][0]+t[1][0]+t[2][0]+t[3][0],s[1]=t[0][1]+t[1][1]+t[2][1]+t[3][1],s[2]=t[0][2]+t[1][2]+t[2][2]+t[3][2]}}var O=class{static expand(n,r){let h=Math.cbrt(n.length/3),i=new Float32Array(3),s=new n.constructor(r**3*3),c=1/(r-1);for(let A=0;A<r;++A)for(let F=0;F<r;++F)for(let e=0;e<r;++e){let l=e*c,w=F*c,f=A*c,y=Math.round(e+F*r+A*r*r)*3;k(n,h,l,w,f,i),s[y+0]=i[0],s[y+1]=i[1],s[y+2]=i[2]}return s}};self.addEventListener("message",a=>{let n=a.data,r=n.data;switch(n.operation){case q.SCALE_UP:r=O.expand(r,n.size);break}postMessage(r,[r.buffer]),close()});})();\n',ft=new d.Color,dt=function(e){(0,s.Z)(n,e);var t=g(n);function n(e,r){var i;return(0,c.Z)(this,n),(i=t.call(this,e,r,r,r)).type=d.FloatType,i.format=d.RGBFormat,i.encoding=d.LinearEncoding,i.minFilter=d.LinearFilter,i.magFilter=d.LinearFilter,i.wrapS=d.ClampToEdgeWrapping,i.wrapT=d.ClampToEdgeWrapping,i.wrapR=d.ClampToEdgeWrapping,i.unpackAlignment=1,i.domainMin=new d.Vector3(0,0,0),i.domainMax=new d.Vector3(1,1,1),i}return(0,f.Z)(n,[{key:"isLookupTexture3D",get:function(){return!0}},{key:"scaleUp",value:function(e){var t,r=this,i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],a=this.image;if(e<=a.width)t=Promise.reject(new Error("The target size must be greater than the current size"));else{var o=URL.createObjectURL(new Blob([ct],{type:"text/javascript"})),s=new Worker(o);t=new Promise((function(t,l){s.addEventListener("error",(function(e){return l(e.error)})),s.addEventListener("message",(function(i){var a=new n(i.data,e);a.encoding=r.encoding,a.type=r.type,a.name=r.name,URL.revokeObjectURL(o),t(a)}));var u=i?[a.data.buffer]:[];s.postMessage({operation:ut,data:a.data,size:e},u)}))}return t}},{key:"applyLUT",value:function(e){var t=this.image,n=e.image,r=Math.min(t.width,t.height,t.depth);if(r!==Math.min(n.width,n.height,n.depth))console.error("Size mismatch");else if(e.type!==d.FloatType||this.type!==d.FloatType)console.error("Both LUTs must be FloatType textures");else if(e.format!==d.RGBFormat||this.format!==d.RGBFormat)console.error("Both LUTs must be RGB textures");else{for(var i=t.data,a=n.data,o=r,s=o-1,l=0,u=Math.pow(o,3);l<u;++l){var c=3*l,f=i[c+0]*s,h=i[c+1]*s,v=i[c+2]*s,g=3*Math.round(f+h*o+v*o*o);i[c+0]=a[g+0],i[c+1]=a[g+1],i[c+2]=a[g+2]}this.needsUpdate=!0}return this}},{key:"convertToUint8",value:function(){if(this.type===d.FloatType){for(var e=this.image.data,t=new Uint8ClampedArray(e.length),n=0,r=e.length;n<r;++n)t[n]=255*e[n];this.image.data=t,this.type=d.UnsignedByteType,this.needsUpdate=!0}return this}},{key:"convertToFloat",value:function(){if(this.type===d.UnsignedByteType){for(var e=this.image.data,t=new Float32Array(e.length),n=0,r=e.length;n<r;++n)t[n]=e[n]/255;this.image.data=t,this.type=d.FloatType,this.needsUpdate=!0}return this}},{key:"convertLinearToSRGB",value:function(){var e=this.image.data;if(this.type===d.FloatType){for(var t=this.format===d.RGBAFormat?4:3,n=0,r=e.length;n<r;n+=t)ft.fromArray(e,n).convertLinearToSRGB().toArray(e,n);this.encoding=d.sRGBEncoding,this.needsUpdate=!0}else console.error("Color space conversion requires FloatType data");return this}},{key:"convertSRGBToLinear",value:function(){var e=this.image.data;if(this.type===d.FloatType){for(var t=this.format===d.RGBAFormat?4:3,n=0,r=e.length;n<r;n+=t)ft.fromArray(e,n).convertSRGBToLinear().toArray(e,n);this.encoding=d.LinearEncoding,this.needsUpdate=!0}else console.error("Color space conversion requires FloatType data");return this}},{key:"convertToRGBA",value:function(){if(this.format===d.RGBFormat){for(var e=this.image.width,t=this.image.data,n=new t.constructor(4*Math.pow(e,3)),r=this.type===d.FloatType?1:255,i=0,a=0,o=t.length;i<o;i+=3,a+=4)n[a+0]=t[i+0],n[a+1]=t[i+1],n[a+2]=t[i+2],n[a+3]=r;this.image.data=n,this.format=d.RGBAFormat,this.needsUpdate=!0}return this}},{key:"toDataTexture",value:function(){var e=this.image.width,t=this.image.height*this.image.depth,n=new d.DataTexture(this.image.data,e,t);return n.name=this.name,n.type=this.type,n.format=this.format,n.encoding=this.encoding,n.minFilter=d.LinearFilter,n.magFilter=d.LinearFilter,n.wrapS=this.wrapS,n.wrapT=this.wrapT,n.generateMipmaps=!1,n}}],[{key:"from",value:function(e){var t,r=e.image,i=r.width,a=r.height,o=Math.min(i,a);if(r instanceof Image){t=lt.from(r).data;var s=new Uint8Array(3*Math.pow(o,3));if(i>a)for(var l=0;l<o;++l)for(var u=0;u<o;++u)for(var c=0;c<o;++c){var f=4*(c+l*o+u*o*o),d=3*(c+u*o+l*o*o);s[d+0]=t[f+0],s[d+1]=t[f+1],s[d+2]=t[f+2]}else for(var h=0,v=Math.pow(o,3);h<v;++h){var g=4*h,A=3*h;s[A+0]=t[g+0],s[A+1]=t[g+1],s[A+2]=t[g+2]}t=s}else t=r.data.slice();var m=new n(t,o);return m.type=e.type,m.encoding=e.encoding,m.name=e.name,m}},{key:"createNeutral",value:function(e){for(var t=new Float32Array(3*Math.pow(e,3)),r=1/(e-1),i=0;i<e;++i)for(var a=0;a<e;++a)for(var o=0;o<e;++o){var s=3*(i+a*e+o*e*e);t[s+0]=i*r,t[s+1]=a*r,t[s+2]=o*r}var l=new n(t,e);return l.name="neutral",l}}]),n}(d.DataTexture3D),ht="void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\tvec3 noise = vec3(rand(uv * time));\r\n\r\n\t#ifdef PREMULTIPLY\r\n\r\n\t\toutputColor = vec4(min(inputColor.rgb * noise, vec3(1.0)), inputColor.a);\r\n\r\n\t#else\r\n\r\n\t\toutputColor = vec4(noise, inputColor.a);\r\n\r\n\t#endif\r\n\r\n}\r\n",vt=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=r.blendFunction,a=void 0===i?ge.SCREEN:i,o=r.premultiply,s=void 0!==o&&o;return(0,c.Z)(this,n),(e=t.call(this,"NoiseEffect",ht,{blendFunction:a})).premultiply=s,e}return(0,f.Z)(n,[{key:"premultiply",get:function(){return this.defines.has("PREMULTIPLY")},set:function(e){this.premultiply!==e&&(e?this.defines.set("PREMULTIPLY","1"):this.defines.delete("PREMULTIPLY"),this.setChanged())}}]),n}(pe),gt="uniform sampler2D edgeTexture;\r\nuniform sampler2D maskTexture;\r\n\r\nuniform vec3 visibleEdgeColor;\r\nuniform vec3 hiddenEdgeColor;\r\nuniform float pulse;\r\nuniform float edgeStrength;\r\n\r\n#ifdef USE_PATTERN\r\n\r\n\tuniform sampler2D patternTexture;\r\n\tvarying vec2 vUvPattern;\r\n\r\n#endif\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\tvec2 edge = texture2D(edgeTexture, uv).rg;\r\n\tvec2 mask = texture2D(maskTexture, uv).rg;\r\n\r\n\t#ifndef X_RAY\r\n\r\n\t\tedge.y = 0.0;\r\n\r\n\t#endif\r\n\r\n\tedge *= (edgeStrength * mask.x * pulse);\r\n\tvec3 color = edge.x * visibleEdgeColor + edge.y * hiddenEdgeColor;\r\n\r\n\tfloat visibilityFactor = 0.0;\r\n\r\n\t#ifdef USE_PATTERN\r\n\r\n\t\tvec4 patternColor = texture2D(patternTexture, vUvPattern);\r\n\r\n\t\t#ifdef X_RAY\r\n\r\n\t\t\tfloat hiddenFactor = 0.5;\r\n\r\n\t\t#else\r\n\r\n\t\t\tfloat hiddenFactor = 0.0;\r\n\r\n\t\t#endif\r\n\r\n\t\tvisibilityFactor = (1.0 - mask.y > 0.0) ? 1.0 : hiddenFactor;\r\n\t\tvisibilityFactor *= (1.0 - mask.x) * patternColor.a;\r\n\t\tcolor += visibilityFactor * patternColor.rgb;\r\n\r\n\t#endif\r\n\r\n\tfloat alpha = max(max(edge.x, edge.y), visibilityFactor);\r\n\r\n\t#ifdef ALPHA\r\n\r\n\t\t// Alpha blending already accounts for input alpha.\r\n\t\toutputColor = vec4(color, alpha);\r\n\r\n\t#else\r\n\r\n\t\t// Preserve input alpha.\r\n\t\toutputColor = vec4(color, max(alpha, inputColor.a));\r\n\r\n\t#endif\r\n\r\n}\r\n",At=function(e){(0,s.Z)(n,e);var t=g(n);function n(e,r){var i,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},s=a.blendFunction,l=void 0===s?ge.SCREEN:s,u=a.patternTexture,f=void 0===u?null:u,h=a.edgeStrength,v=void 0===h?1:h,g=a.pulseSpeed,A=void 0===g?0:g,m=a.visibleEdgeColor,p=void 0===m?16777215:m,y=a.hiddenEdgeColor,x=void 0===y?2230538:y,w=a.resolutionScale,C=void 0===w?.5:w,D=a.width,E=void 0===D?oe.AUTO_SIZE:D,B=a.height,T=void 0===B?oe.AUTO_SIZE:B,M=a.kernelSize,S=void 0===M?F.VERY_SMALL:M,P=a.blur,I=void 0!==P&&P,b=a.xRay,R=void 0===b||b;(0,c.Z)(this,n),(i=t.call(this,"OutlineEffect",gt,{uniforms:new Map([["maskTexture",new d.Uniform(null)],["edgeTexture",new d.Uniform(null)],["edgeStrength",new d.Uniform(v)],["visibleEdgeColor",new d.Uniform(new d.Color(p))],["hiddenEdgeColor",new d.Uniform(new d.Color(x))],["pulse",new d.Uniform(1)],["patternScale",new d.Uniform(1)],["patternTexture",new d.Uniform(null)]])})).blendMode.addEventListener("change",(function(e){i.blendMode.getBlendFunction()===ge.ALPHA?i.defines.set("ALPHA","1"):i.defines.delete("ALPHA"),i.setChanged()})),i.blendMode.setBlendFunction(l),i.setPatternTexture(f),i.xRay=R,i.scene=e,i.camera=r,i.renderTargetMask=new d.WebGLRenderTarget(1,1,{minFilter:d.LinearFilter,magFilter:d.LinearFilter,stencilBuffer:!1,format:d.RGBFormat}),i.renderTargetMask.texture.name="Outline.Mask",i.uniforms.get("maskTexture").value=i.renderTargetMask.texture,i.renderTargetOutline=i.renderTargetMask.clone(),i.renderTargetOutline.texture.name="Outline.Edges",i.renderTargetOutline.depthBuffer=!1,i.renderTargetBlurredOutline=i.renderTargetOutline.clone(),i.renderTargetBlurredOutline.texture.name="Outline.BlurredEdges",i.clearPass=new ce,i.clearPass.overrideClearColor=new d.Color(0),i.clearPass.overrideClearAlpha=1,i.depthPass=new ve(e,r),i.maskPass=new he(e,r,new U(i.depthPass.texture,r));var k=i.maskPass.getClearPass();return k.overrideClearColor=new d.Color(16777215),k.overrideClearAlpha=1,i.blurPass=new se({resolutionScale:C,width:E,height:T,kernelSize:S}),i.blurPass.resolution.resizable=(0,o.Z)(i),i.blur=I,i.outlinePass=new Te(new j),i.outlinePass.getFullscreenMaterial().uniforms.inputBuffer.value=i.renderTargetMask.texture,i.time=0,i.selection=new Se,i.pulseSpeed=A,i}return(0,f.Z)(n,[{key:"resolution",get:function(){return this.blurPass.resolution}},{key:"width",get:function(){return this.resolution.width},set:function(e){this.resolution.width=e}},{key:"height",get:function(){return this.resolution.height},set:function(e){this.resolution.height=e}},{key:"selectionLayer",get:function(){return this.selection.layer},set:function(e){this.selection.layer=e}},{key:"dithering",get:function(){return this.blurPass.dithering},set:function(e){this.blurPass.dithering=e}},{key:"kernelSize",get:function(){return this.blurPass.kernelSize},set:function(e){this.blurPass.kernelSize=e}},{key:"blur",get:function(){return this.blurPass.enabled},set:function(e){this.blurPass.enabled=e,this.uniforms.get("edgeTexture").value=e?this.renderTargetBlurredOutline.texture:this.renderTargetOutline.texture}},{key:"xRay",get:function(){return this.defines.has("X_RAY")},set:function(e){this.xRay!==e&&(e?this.defines.set("X_RAY","1"):this.defines.delete("X_RAY"),this.setChanged())}},{key:"setPatternTexture",value:function(e){null!==e?(e.wrapS=e.wrapT=d.RepeatWrapping,this.defines.set("USE_PATTERN","1"),this.uniforms.get("patternTexture").value=e,this.setVertexShader("uniform float patternScale;\r\n\r\nvarying vec2 vUvPattern;\r\n\r\nvoid mainSupport(const in vec2 uv) {\r\n\r\n\tvUvPattern = uv * vec2(aspect, 1.0) * patternScale;\r\n\r\n}\r\n")):(this.defines.delete("USE_PATTERN"),this.uniforms.get("patternTexture").value=null,this.setVertexShader(null)),this.setChanged()}},{key:"getResolutionScale",value:function(){return this.resolution.scale}},{key:"setResolutionScale",value:function(e){this.resolution.scale=e}},{key:"setSelection",value:function(e){return this.selection.set(e),this}},{key:"clearSelection",value:function(){return this.selection.clear(),this}},{key:"selectObject",value:function(e){return this.selection.add(e),this}},{key:"deselectObject",value:function(e){return this.selection.delete(e),this}},{key:"update",value:function(e,t,n){var r=this.scene,i=this.camera,a=this.selection,o=this.uniforms.get("pulse"),s=r.background,l=i.layers.mask;a.size>0?(r.background=null,o.value=1,this.pulseSpeed>0&&(o.value=.625+.375*Math.cos(this.time*this.pulseSpeed*10)),this.time+=n,a.setVisible(!1),this.depthPass.render(e),a.setVisible(!0),i.layers.set(a.layer),this.maskPass.render(e,this.renderTargetMask),i.layers.mask=l,r.background=s,this.outlinePass.render(e,null,this.renderTargetOutline),this.blur&&this.blurPass.render(e,this.renderTargetOutline,this.renderTargetBlurredOutline)):this.time>0&&(this.clearPass.render(e,this.renderTargetMask),this.time=0)}},{key:"setSize",value:function(e,t){this.blurPass.setSize(e,t),this.renderTargetMask.setSize(e,t);var n=this.resolution.width,r=this.resolution.height;this.depthPass.setSize(n,r),this.renderTargetOutline.setSize(n,r),this.renderTargetBlurredOutline.setSize(n,r),this.outlinePass.getFullscreenMaterial().setTexelSize(1/n,1/r)}},{key:"initialize",value:function(e,t,n){this.blurPass.initialize(e,t,d.UnsignedByteType),void 0!==n&&(this.depthPass.initialize(e,t,n),this.maskPass.initialize(e,t,n),this.outlinePass.initialize(e,t,n))}}]),n}(pe),mt="uniform bool active;\r\nuniform vec2 d;\r\n\r\nvoid mainUv(inout vec2 uv) {\r\n\r\n\tif(active) {\r\n\r\n\t\tuv = vec2(\r\n\t\t\td.x * (floor(uv.x / d.x) + 0.5),\r\n\t\t\td.y * (floor(uv.y / d.y) + 0.5)\r\n\t\t);\r\n\r\n\t}\r\n\r\n}\r\n",pt=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:30;return(0,c.Z)(this,n),(e=t.call(this,"PixelationEffect",mt,{uniforms:new Map([["active",new d.Uniform(!1)],["d",new d.Uniform(new d.Vector2)]])})).resolution=new d.Vector2,e.granularity=r,e}return(0,f.Z)(n,[{key:"getGranularity",value:function(){return this.granularity}},{key:"setGranularity",value:function(e){(e=Math.floor(e))%2>0&&(e+=1);var t=this.uniforms;t.get("active").value=e>0,t.get("d").value.set(e,e).divide(this.resolution),this.granularity=e}},{key:"setSize",value:function(e,t){this.resolution.set(e,t),this.setGranularity(this.granularity)}}]),n}(pe),yt="uniform float count;\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\tvec2 sl = vec2(sin(uv.y * count), cos(uv.y * count));\r\n\tvec3 scanlines = vec3(sl.x, sl.y, sl.x);\r\n\r\n\toutputColor = vec4(scanlines, inputColor.a);\r\n\r\n}\r\n",xt=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=r.blendFunction,a=void 0===i?ge.OVERLAY:i,o=r.density,s=void 0===o?1.25:o;return(0,c.Z)(this,n),(e=t.call(this,"ScanlineEffect",yt,{blendFunction:a,uniforms:new Map([["count",new d.Uniform(0)]])})).resolution=new d.Vector2,e.density=s,e}return(0,f.Z)(n,[{key:"getDensity",value:function(){return this.density}},{key:"setDensity",value:function(e){this.density=e,this.setSize(this.resolution.x,this.resolution.y)}},{key:"setSize",value:function(e,t){this.resolution.set(e,t),this.uniforms.get("count").value=Math.round(t*this.density)}}]),n}(pe),wt=(Math.PI,new d.Vector3,new d.Vector3,function(e){(0,s.Z)(n,e);var t=g(n);function n(e,r,i){var a,o,s;return(0,c.Z)(this,n),(a=t.call(this,i)).scene=e,a.camera=r,a.clearPass=new ce(!0,!0,!1),a.clearPass.overrideClearColor=new d.Color(0),a.renderPass=new he(e,r),a.renderPass.clear=!1,a.blackoutPass=new he(e,r,new d.MeshBasicMaterial({color:0})),a.blackoutPass.clear=!1,a.backgroundPass=(o=new d.Scene,s=new he(o,r),o.background=e.background,s.clear=!1,s),a.renderTargetSelection=new d.WebGLRenderTarget(1,1,{minFilter:d.LinearFilter,magFilter:d.LinearFilter,stencilBuffer:!1,depthBuffer:!0}),a.renderTargetSelection.texture.name="Bloom.Selection",a.renderTargetSelection.texture.generateMipmaps=!1,a.selection=new Se,a.inverted=!1,a}return(0,f.Z)(n,[{key:"ignoreBackground",get:function(){return!this.backgroundPass.enabled},set:function(e){this.backgroundPass.enabled=!e}},{key:"update",value:function(e,t,r){var i=this.scene,o=this.camera,s=this.selection,l=this.renderTargetSelection,c=i.background,f=o.layers.mask;this.clearPass.render(e,l),this.ignoreBackground||this.backgroundPass.render(e,l),i.background=null,this.inverted?(o.layers.set(s.layer),this.blackoutPass.render(e,l),o.layers.mask=f,s.setVisible(!1),this.renderPass.render(e,l),s.setVisible(!0)):(s.setVisible(!1),this.blackoutPass.render(e,l),s.setVisible(!0),o.layers.set(s.layer),this.renderPass.render(e,l),o.layers.mask=f),i.background=c,(0,a.Z)((0,u.Z)(n.prototype),"update",this).call(this,e,l,r)}},{key:"setSize",value:function(e,t){(0,a.Z)((0,u.Z)(n.prototype),"setSize",this).call(this,e,t),this.backgroundPass.setSize(e,t),this.blackoutPass.setSize(e,t),this.renderPass.setSize(e,t),this.renderTargetSelection.setSize(this.resolution.width,this.resolution.height)}},{key:"initialize",value:function(e,t,r){(0,a.Z)((0,u.Z)(n.prototype),"initialize",this).call(this,e,t,r),this.backgroundPass.initialize(e,t,r),this.blackoutPass.initialize(e,t,r),this.renderPass.initialize(e,t,r),t||r!==d.UnsignedByteType||(this.renderTargetSelection.texture.format=d.RGBFormat),void 0!==r&&(this.renderTargetSelection.texture.type=r)}}]),n}(Ie)),Ct="uniform float intensity;\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\tvec3 color = vec3(\r\n\t\tdot(inputColor.rgb, vec3(1.0 - 0.607 * intensity, 0.769 * intensity, 0.189 * intensity)),\r\n\t\tdot(inputColor.rgb, vec3(0.349 * intensity, 1.0 - 0.314 * intensity, 0.168 * intensity)),\r\n\t\tdot(inputColor.rgb, vec3(0.272 * intensity, 0.534 * intensity, 1.0 - 0.869 * intensity))\r\n\t);\r\n\r\n\toutputColor = vec4(color, inputColor.a);\r\n\r\n}\r\n",Dt=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.blendFunction,i=void 0===r?ge.NORMAL:r,a=e.intensity,o=void 0===a?1:a;return(0,c.Z)(this,n),t.call(this,"SepiaEffect",Ct,{blendFunction:i,uniforms:new Map([["intensity",new d.Uniform(o)]])})}return(0,f.Z)(n)}(pe),Et="uniform sampler2D weightMap;\r\n\r\nvarying vec2 vOffset0;\r\nvarying vec2 vOffset1;\r\n\r\n/**\r\n * Moves values to a target vector based on a given conditional vector.\r\n */\r\n\r\nvoid movec(const in bvec2 c, inout vec2 variable, const in vec2 value) {\r\n\r\n\tif(c.x) { variable.x = value.x; }\r\n\tif(c.y) { variable.y = value.y; }\r\n\r\n}\r\n\r\nvoid movec(const in bvec4 c, inout vec4 variable, const in vec4 value) {\r\n\r\n\tmovec(c.xy, variable.xy, value.xy);\r\n\tmovec(c.zw, variable.zw, value.zw);\r\n\r\n}\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\t// Fetch the blending weights for the current pixel.\r\n\tvec4 a;\r\n\ta.x = texture2D(weightMap, vOffset0).a;\r\n\ta.y = texture2D(weightMap, vOffset1).g;\r\n\ta.wz = texture2D(weightMap, uv).rb;\r\n\r\n\tvec4 color = inputColor;\r\n\r\n\t// Ignore tiny blending weights.\r\n\tif(dot(a, vec4(1.0)) >= 1e-5) {\r\n\r\n\t\t// max(horizontal) > max(vertical)\r\n\t\tbool h = max(a.x, a.z) > max(a.y, a.w);\r\n\r\n\t\t// Calculate the blending offsets.\r\n\t\tvec4 blendingOffset = vec4(0.0, a.y, 0.0, a.w);\r\n\t\tvec2 blendingWeight = a.yw;\r\n\t\tmovec(bvec4(h), blendingOffset, vec4(a.x, 0.0, a.z, 0.0));\r\n\t\tmovec(bvec2(h), blendingWeight, a.xz);\r\n\t\tblendingWeight /= dot(blendingWeight, vec2(1.0));\r\n\r\n\t\t// Calculate the texture coordinates.\r\n\t\tvec4 blendingCoord = blendingOffset * vec4(texelSize, -texelSize) + uv.xyxy;\r\n\r\n\t\t// Rely on bilinear filtering to mix the current pixel with the neighbor.\r\n\t\tcolor = blendingWeight.x * texture2D(inputBuffer, blendingCoord.xy);\r\n\t\tcolor += blendingWeight.y * texture2D(inputBuffer, blendingCoord.zw);\r\n\r\n\t}\r\n\r\n\toutputColor = color;\r\n\r\n}\r\n",Bt="varying vec2 vOffset0;\r\nvarying vec2 vOffset1;\r\n\r\nvoid mainSupport(const in vec2 uv) {\r\n\r\n\tvOffset0 = uv + texelSize * vec2(1.0, 0.0);\r\n\tvOffset1 = uv + texelSize * vec2(0.0, 1.0);\r\n\r\n}\r\n",Tt=function(e){(0,s.Z)(n,e);var t=g(n);function n(e,r){var i,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Mt.HIGH,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:G.COLOR;(0,c.Z)(this,n),(i=t.call(this,"SMAAEffect",Et,{vertexShader:Bt,blendFunction:ge.NORMAL,attributes:ye.CONVOLUTION|ye.DEPTH,uniforms:new Map([["weightMap",new d.Uniform(null)]])})).renderTargetEdges=new d.WebGLRenderTarget(1,1,{minFilter:d.LinearFilter,stencilBuffer:!1,depthBuffer:!1,format:d.RGBFormat}),i.renderTargetEdges.texture.name="SMAA.Edges",i.renderTargetWeights=i.renderTargetEdges.clone(),i.renderTargetWeights.texture.name="SMAA.Weights",i.renderTargetWeights.texture.format=d.RGBAFormat,i.uniforms.get("weightMap").value=i.renderTargetWeights.texture,i.clearPass=new ce(!0,!1,!1),i.clearPass.overrideClearColor=new d.Color(0),i.clearPass.overrideClearAlpha=1,i.edgeDetectionPass=new Te(new O(new d.Vector2,o)),i.weightsPass=new Te(new _);var s=new d.Texture(e);s.name="SMAA.Search",s.magFilter=d.NearestFilter,s.minFilter=d.NearestFilter,s.format=d.RGBAFormat,s.generateMipmaps=!1,s.needsUpdate=!0,s.flipY=!0;var l=new d.Texture(r);l.name="SMAA.Area",l.minFilter=d.LinearFilter,l.format=d.RGBAFormat,l.generateMipmaps=!1,l.needsUpdate=!0,l.flipY=!1;var u=i.weightsPass.getFullscreenMaterial();return u.uniforms.searchTexture.value=s,u.uniforms.areaTexture.value=l,i.applyPreset(a),i}return(0,f.Z)(n,[{key:"edgeDetectionMaterial",get:function(){return this.edgeDetectionPass.getFullscreenMaterial()}},{key:"colorEdgesMaterial",get:function(){return this.edgeDetectionMaterial}},{key:"weightsMaterial",get:function(){return this.weightsPass.getFullscreenMaterial()}},{key:"setEdgeDetectionThreshold",value:function(e){this.edgeDetectionPass.getFullscreenMaterial().setEdgeDetectionThreshold(e)}},{key:"setOrthogonalSearchSteps",value:function(e){this.weightsPass.getFullscreenMaterial().setOrthogonalSearchSteps(e)}},{key:"applyPreset",value:function(e){var t=this.edgeDetectionMaterial,n=this.weightsMaterial;switch(e){case Mt.LOW:t.setEdgeDetectionThreshold(.15),n.setOrthogonalSearchSteps(4),n.diagonalDetection=!1,n.cornerRounding=!1;break;case Mt.MEDIUM:t.setEdgeDetectionThreshold(.1),n.setOrthogonalSearchSteps(8),n.diagonalDetection=!1,n.cornerRounding=!1;break;case Mt.HIGH:t.setEdgeDetectionThreshold(.1),n.setOrthogonalSearchSteps(16),n.setDiagonalSearchSteps(8),n.setCornerRounding(25),n.diagonalDetection=!0,n.cornerRounding=!0;break;case Mt.ULTRA:t.setEdgeDetectionThreshold(.05),n.setOrthogonalSearchSteps(32),n.setDiagonalSearchSteps(16),n.setCornerRounding(25),n.diagonalDetection=!0,n.cornerRounding=!0}}},{key:"setDepthTexture",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=this.edgeDetectionMaterial;n.uniforms.depthBuffer.value=e,n.depthPacking=t}},{key:"update",value:function(e,t,n){this.clearPass.render(e,this.renderTargetEdges),this.edgeDetectionPass.render(e,t,this.renderTargetEdges),this.weightsPass.render(e,this.renderTargetEdges,this.renderTargetWeights)}},{key:"setSize",value:function(e,t){var n=this.edgeDetectionPass.getFullscreenMaterial(),r=this.weightsPass.getFullscreenMaterial();this.renderTargetEdges.setSize(e,t),this.renderTargetWeights.setSize(e,t),r.uniforms.resolution.value.set(e,t),r.uniforms.texelSize.value.set(1/e,1/t),n.uniforms.texelSize.value.copy(r.uniforms.texelSize.value)}},{key:"dispose",value:function(){var e=this.weightsPass.getFullscreenMaterial().uniforms;e.searchTexture.value.dispose(),e.areaTexture.value.dispose(),(0,a.Z)((0,u.Z)(n.prototype),"dispose",this).call(this)}}],[{key:"searchImageDataURL",get:function(){return"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC"}},{key:"areaImageDataURL",get:function(){return"data:image/png;base64,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"}}]),n}(pe),Mt={LOW:0,MEDIUM:1,HIGH:2,ULTRA:3},St="uniform sampler2D aoBuffer;\r\nuniform float luminanceInfluence;\r\n\r\n#ifdef DEPTH_AWARE_UPSAMPLING\r\n\r\n\t#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\r\n\t\tuniform highp sampler2D normalDepthBuffer;\r\n\r\n\t#else\r\n\r\n\t\tuniform mediump sampler2D normalDepthBuffer;\r\n\r\n\t#endif\r\n\r\n#endif\r\n\r\n#ifdef COLORIZE\r\n\r\n\tuniform vec3 color;\r\n\r\n#endif\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, const in float depth, out vec4 outputColor) {\r\n\r\n\tfloat aoLinear = texture2D(aoBuffer, uv).r;\r\n\r\n\t#if defined(DEPTH_AWARE_UPSAMPLING) && __VERSION__ == 300\r\n\r\n\t\t// Gather normals and depth in a 2x2 neighborhood.\r\n\t\tvec4 normalDepth[4] = vec4[](\r\n\t\t\ttextureOffset(normalDepthBuffer, uv, ivec2(0, 0)),\r\n\t\t\ttextureOffset(normalDepthBuffer, uv, ivec2(0, 1)),\r\n\t\t\ttextureOffset(normalDepthBuffer, uv, ivec2(1, 0)),\r\n\t\t\ttextureOffset(normalDepthBuffer, uv, ivec2(1, 1))\r\n\t\t);\r\n\r\n\t\t// Determine the smoothness of the surface around this fragment.\r\n\t\tfloat dot01 = dot(normalDepth[0].rgb, normalDepth[1].rgb);\r\n\t\tfloat dot02 = dot(normalDepth[0].rgb, normalDepth[2].rgb);\r\n\t\tfloat dot03 = dot(normalDepth[0].rgb, normalDepth[3].rgb);\r\n\r\n\t\tfloat minDot = min(dot01, min(dot02, dot03));\r\n\t\tfloat s = step(THRESHOLD, minDot);\r\n\r\n\t\t// Find the best AO based on depth.\r\n\t\tfloat smallestDistance = 1.0;\r\n\t\tint index;\r\n\r\n\t\tfor(int i = 0; i < 4; ++i) {\r\n\r\n\t\t\tfloat distance = abs(depth - normalDepth[i].a);\r\n\r\n\t\t\tif(distance < smallestDistance) {\r\n\r\n\t\t\t\tsmallestDistance = distance;\r\n\t\t\t\tindex = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n \r\n\t\t// Fetch the exact AO texel that corresponds to the best depth.\r\n\t\tivec2 offsets[4] = ivec2[](\r\n\t\t\tivec2(0, 0), ivec2(0, 1),\r\n\t\t\tivec2(1, 0), ivec2(1, 1)\r\n\t\t);\r\n\r\n\t\tivec2 coord = ivec2(uv * vec2(textureSize(aoBuffer, 0))) + offsets[index];\r\n\t\tfloat aoNearest = texelFetch(aoBuffer, coord, 0).r;\r\n\r\n\t\t// Smooth surfaces benefit more from linear filtering.\r\n\t\tfloat ao = mix(aoNearest, aoLinear, s);\r\n\r\n\t#else\r\n\r\n\t\tfloat ao = aoLinear;\r\n\r\n\t#endif\r\n\r\n\t// Fade AO based on luminance.\r\n\tfloat l = linearToRelativeLuminance(inputColor.rgb);\r\n\tao = mix(ao, 1.0, l * luminanceInfluence);\r\n\r\n\t#ifdef COLORIZE\r\n\r\n\t\toutputColor = vec4(1.0 - (1.0 - ao) * (1.0 - color), inputColor.a);\r\n\r\n\t#else\r\n\r\n\t\toutputColor = vec4(vec3(ao), inputColor.a);\r\n\r\n\t#endif\r\n\r\n}\r\n",Pt=function(e){(0,s.Z)(n,e);var t=g(n);function n(e,r){var i,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},s=a.blendFunction,l=void 0===s?ge.MULTIPLY:s,u=a.distanceScaling,f=void 0===u||u,h=a.depthAwareUpsampling,v=void 0===h||h,g=a.normalDepthBuffer,A=void 0===g?null:g,m=a.samples,p=void 0===m?9:m,y=a.rings,x=void 0===y?7:y,w=a.distanceThreshold,C=void 0===w?.97:w,D=a.distanceFalloff,E=void 0===D?.03:D,B=a.rangeThreshold,T=void 0===B?5e-4:B,M=a.rangeFalloff,S=void 0===M?.001:M,P=a.minRadiusScale,I=void 0===P?.33:P,F=a.luminanceInfluence,b=void 0===F?.7:F,R=a.radius,k=void 0===R?.1825:R,U=a.intensity,L=void 0===U?1:U,O=a.bias,G=void 0===O?.025:O,N=a.fade,H=void 0===N?.01:N,z=a.color,Q=void 0===z?null:z,Z=a.resolutionScale,V=void 0===Z?1:Z,Y=a.width,X=void 0===Y?oe.AUTO_SIZE:Y,W=a.height,K=void 0===W?oe.AUTO_SIZE:W;return(0,c.Z)(this,n),(i=t.call(this,"SSAOEffect",St,{blendFunction:l,attributes:ye.DEPTH,uniforms:new Map([["aoBuffer",new d.Uniform(null)],["normalDepthBuffer",new d.Uniform(null)],["luminanceInfluence",new d.Uniform(b)],["color",new d.Uniform(null)],["scale",new d.Uniform(0)]])})).renderTargetAO=new d.WebGLRenderTarget(1,1,{minFilter:d.LinearFilter,magFilter:d.LinearFilter,stencilBuffer:!1,depthBuffer:!1,format:d.RGBFormat}),i.renderTargetAO.texture.name="AO.Target",i.renderTargetAO.texture.generateMipmaps=!1,i.uniforms.get("aoBuffer").value=i.renderTargetAO.texture,i.resolution=new oe((0,o.Z)(i),X,K,V),i.r=1,i.camera=e,i.ssaoPass=new Te(function(){var t=new We(64,64);t.wrapS=t.wrapT=d.RepeatWrapping;var n=new $(e);return n.uniforms.noiseTexture.value=t,n.uniforms.intensity.value=L,n.uniforms.minRadiusScale.value=I,n.uniforms.fade.value=H,n.uniforms.bias.value=G,null!==A?(n.uniforms.normalDepthBuffer.value=A,n.defines.NORMAL_DEPTH="1",v&&(i.depthAwareUpsampling=v,i.uniforms.get("normalDepthBuffer").value=A,i.defines.set("THRESHOLD","0.997"))):n.uniforms.normalBuffer.value=r,n}()),i.distanceScaling=f,i.samples=p,i.rings=x,i.color=Q,i.radius=k>1?k/100:k,i.setDistanceCutoff(C,E),i.setProximityCutoff(T,S),i}return(0,f.Z)(n,[{key:"ssaoMaterial",get:function(){return this.ssaoPass.getFullscreenMaterial()}},{key:"samples",get:function(){return Number(this.ssaoMaterial.defines.SAMPLES_INT)},set:function(e){var t=this.ssaoMaterial;t.defines.SAMPLES_INT=e.toFixed(0),t.defines.SAMPLES_FLOAT=e.toFixed(1),t.needsUpdate=!0}},{key:"rings",get:function(){return Number(this.ssaoMaterial.defines.SPIRAL_TURNS)},set:function(e){var t=this.ssaoMaterial;t.defines.SPIRAL_TURNS=e.toFixed(1),t.needsUpdate=!0}},{key:"radius",get:function(){return this.r},set:function(e){this.r=Math.min(Math.max(e,1e-6),1);var t=this.r*this.resolution.height,n=this.ssaoMaterial;n.defines.RADIUS=t.toFixed(11),n.defines.RADIUS_SQ=(t*t).toFixed(11),n.needsUpdate=!0}},{key:"depthAwareUpsampling",get:function(){return this.defines.has("DEPTH_AWARE_UPSAMPLING")},set:function(e){this.depthAwareUpsampling!==e&&(e?this.defines.set("DEPTH_AWARE_UPSAMPLING","1"):this.defines.delete("DEPTH_AWARE_UPSAMPLING"),this.setChanged())}},{key:"distanceScaling",get:function(){return void 0!==this.ssaoMaterial.defines.DISTANCE_SCALING},set:function(e){if(this.distanceScaling!==e){var t=this.ssaoMaterial;e?t.defines.DISTANCE_SCALING="1":delete t.defines.DISTANCE_SCALING,t.needsUpdate=!0}}},{key:"color",get:function(){return this.uniforms.get("color").value},set:function(e){var t=this.uniforms,n=this.defines;null!==e?n.has("COLORIZE")?t.get("color").value.set(e):(n.set("COLORIZE","1"),t.get("color").value=new d.Color(e),this.setChanged()):n.has("COLORIZE")&&(n.delete("COLORIZE"),t.get("color").value=null,this.setChanged())}},{key:"setDistanceCutoff",value:function(e,t){this.ssaoMaterial.uniforms.distanceCutoff.value.set(Math.min(Math.max(e,0),1),Math.min(Math.max(e+t,0),1))}},{key:"setProximityCutoff",value:function(e,t){this.ssaoMaterial.uniforms.proximityCutoff.value.set(Math.min(Math.max(e,0),1),Math.min(Math.max(e+t,0),1))}},{key:"setDepthTexture",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=this.ssaoMaterial;void 0===n.defines.NORMAL_DEPTH&&(n.uniforms.normalDepthBuffer.value=e,n.depthPacking=t)}},{key:"update",value:function(e,t,n){this.ssaoPass.render(e,null,this.renderTargetAO)}},{key:"setSize",value:function(e,t){var n=this.resolution;n.base.set(e,t);var r=n.width,i=n.height;this.renderTargetAO.setSize(r,i),this.ssaoMaterial.setTexelSize(1/r,1/i);var a=this.camera,o=this.ssaoMaterial.uniforms;o.noiseScale.value.set(r,i).divideScalar(64),o.inverseProjectionMatrix.value.copy(a.projectionMatrix).invert(),o.projectionMatrix.value.copy(a.projectionMatrix),this.radius=this.r}}]),n}(pe),It="uniform sampler2D texture;\r\n\r\n#if defined(ASPECT_CORRECTION) || defined(UV_TRANSFORM)\r\n\r\n\tvarying vec2 vUv2;\r\n\r\n#endif\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\t#if defined(ASPECT_CORRECTION) || defined(UV_TRANSFORM)\r\n\r\n\t\tvec4 texel = texelToLinear(texture2D(texture, vUv2));\r\n\r\n\t#else\r\n\r\n\t\tvec4 texel = texelToLinear(texture2D(texture, uv));\r\n\r\n\t#endif\r\n\r\n\toutputColor = TEXEL;\r\n\r\n}\r\n",Ft="#ifdef ASPECT_CORRECTION\r\n\r\n\tuniform float scale;\r\n\r\n#else\r\n\r\n\tuniform mat3 uvTransform;\r\n\r\n#endif\r\n\r\nvarying vec2 vUv2;\r\n\r\nvoid mainSupport(const in vec2 uv) {\r\n\r\n\t#ifdef ASPECT_CORRECTION\r\n\r\n\t\tvUv2 = uv * vec2(aspect, 1.0) * scale;\r\n\r\n\t#else\r\n\r\n\t\tvUv2 = (uvTransform * vec3(uv, 1.0)).xy;\r\n\r\n\t#endif\r\n\r\n}\r\n",bt=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=r.blendFunction,a=void 0===i?ge.NORMAL:i,o=r.texture,s=void 0===o?null:o,l=r.aspectCorrection,u=void 0!==l&&l;return(0,c.Z)(this,n),(e=t.call(this,"TextureEffect",It,{blendFunction:a,defines:new Map([["TEXEL","texel"]]),uniforms:new Map([["texture",new d.Uniform(null)],["scale",new d.Uniform(1)],["uvTransform",new d.Uniform(null)]])})).texture=s,e.aspectCorrection=u,e}return(0,f.Z)(n,[{key:"texture",get:function(){return this.uniforms.get("texture").value},set:function(e){var t=this.texture;if(t!==e){var n=null!==t?t.encoding:null;if(this.uniforms.get("texture").value=e,null!==e){switch(e.encoding){case d.sRGBEncoding:this.defines.set("texelToLinear(texel)","sRGBToLinear(texel)");break;case d.LinearEncoding:this.defines.set("texelToLinear(texel)","texel");break;default:console.error("Unsupported encoding:",e.encoding)}n!==e.encoding&&this.setChanged()}}}},{key:"aspectCorrection",get:function(){return this.defines.has("ASPECT_CORRECTION")},set:function(e){this.aspectCorrection!==e&&(e?(this.uvTransform&&(this.uvTransform=!1),this.defines.set("ASPECT_CORRECTION","1"),this.setVertexShader(Ft)):(this.defines.delete("ASPECT_CORRECTION"),this.setVertexShader(null)),this.setChanged())}},{key:"uvTransform",get:function(){return this.defines.has("UV_TRANSFORM")},set:function(e){this.uvTransform!==e&&(e?(this.aspectCorrection&&(this.aspectCorrection=!1),this.defines.set("UV_TRANSFORM","1"),this.uniforms.get("uvTransform").value=new d.Matrix3,this.setVertexShader(Ft)):(this.defines.delete("UV_TRANSFORM"),this.uniforms.get("uvTransform").value=null,this.setVertexShader(null)),this.setChanged())}},{key:"setTextureSwizzleRGBA",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e,i="rgba",a="";e===A&&t===m&&n===p&&r===y||(a=[".",i[e],i[t],i[n],i[r]].join("")),this.defines.set("TEXEL","texel"+a),this.setChanged()}},{key:"update",value:function(e,t,n){var r=this.uniforms.get("texture").value;this.uvTransform&&r.matrixAutoUpdate&&(r.updateMatrix(),this.uniforms.get("uvTransform").value.copy(r.matrix))}}]),n}(pe),Rt="#include <tonemapping_pars_fragment>\r\n\r\nuniform sampler2D luminanceBuffer;\r\nuniform float whitePoint;\r\nuniform float middleGrey;\r\n\r\n#ifndef ADAPTIVE\r\n\r\n\tuniform float averageLuminance;\r\n\r\n#endif\r\n\r\nvec3 Reinhard2ToneMapping(vec3 color) {\r\n\r\n\tcolor *= toneMappingExposure;\r\n\r\n\t// Calculate the luminance of the current pixel.\r\n\tfloat l = linearToRelativeLuminance(color);\r\n\r\n\t#ifdef ADAPTIVE\r\n\r\n\t\t// Get the average luminance from the adaptive 1x1 buffer.\r\n\t\tfloat lumAvg = texture2D(luminanceBuffer, vec2(0.5)).r;\r\n\r\n\t#else\r\n\r\n\t\tfloat lumAvg = averageLuminance;\r\n\r\n\t#endif\r\n\r\n\tfloat lumScaled = (l * middleGrey) / max(lumAvg, 1e-6);\r\n\tfloat lumCompressed = lumScaled * (1.0 + lumScaled / (whitePoint * whitePoint));\r\n\tlumCompressed /= (1.0 + lumScaled);\r\n\r\n\treturn clamp(lumCompressed * color, 0.0, 1.0);\r\n\r\n}\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\t#ifdef REINHARD2\r\n\r\n\t\toutputColor = vec4(Reinhard2ToneMapping(inputColor.rgb), inputColor.a);\r\n\r\n\t#else\r\n\r\n\t\toutputColor = vec4(toneMapping(inputColor.rgb), inputColor.a);\r\n\r\n\t#endif\r\n\r\n}\r\n",kt=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=r.blendFunction,a=void 0===i?ge.NORMAL:i,o=r.adaptive,s=void 0===o||o,l=r.mode,u=void 0===l?s?Ut.REINHARD2_ADAPTIVE:Ut.REINHARD2:l,f=r.resolution,h=void 0===f?256:f,v=r.maxLuminance,g=void 0===v?16:v,A=r.whitePoint,m=void 0===A?g:A,p=r.middleGrey,y=void 0===p?.6:p,x=r.minLuminance,w=void 0===x?.01:x,C=r.averageLuminance,D=void 0===C?1:C,E=r.adaptationRate,B=void 0===E?1:E;return(0,c.Z)(this,n),(e=t.call(this,"ToneMappingEffect",Rt,{blendFunction:a,uniforms:new Map([["luminanceBuffer",new d.Uniform(null)],["maxLuminance",new d.Uniform(g)],["whitePoint",new d.Uniform(m)],["middleGrey",new d.Uniform(y)],["averageLuminance",new d.Uniform(D)]])})).renderTargetLuminance=new d.WebGLRenderTarget(1,1,{minFilter:void 0!==d.LinearMipmapLinearFilter?d.LinearMipmapLinearFilter:d.LinearMipMapLinearFilter,magFilter:d.LinearFilter,stencilBuffer:!1,depthBuffer:!1,format:d.RGBFormat}),e.renderTargetLuminance.texture.name="Luminance",e.renderTargetLuminance.texture.generateMipmaps=!0,e.luminancePass=new Te(new Z),e.adaptiveLuminancePass=new ie(e.renderTargetLuminance.texture,{minLuminance:w,adaptationRate:B}),e.uniforms.get("luminanceBuffer").value=e.adaptiveLuminancePass.texture,e.mode=null,e.setMode(u),e.resolution=h,e}return(0,f.Z)(n,[{key:"getMode",value:function(){return this.mode}},{key:"setMode",value:function(e){if(this.mode!==e){switch(this.defines.clear(),e){case Ut.REINHARD:this.defines.set("toneMapping(texel)","ReinhardToneMapping(texel)");break;case Ut.OPTIMIZED_CINEON:this.defines.set("toneMapping(texel)","OptimizedCineonToneMapping(texel)");break;case Ut.ACES_FILMIC:this.defines.set("toneMapping(texel)","ACESFilmicToneMapping(texel)");break;default:this.defines.set("toneMapping(texel)","texel")}e===Ut.REINHARD2?this.defines.set("REINHARD2","1"):e===Ut.REINHARD2_ADAPTIVE&&(this.defines.set("REINHARD2","1"),this.defines.set("ADAPTIVE","1")),this.mode=e,this.setChanged()}}},{key:"resolution",get:function(){return this.renderTargetLuminance.width},set:function(e){var t=Math.max(0,Math.ceil(Math.log2(e))),n=Math.pow(2,t);this.renderTargetLuminance.setSize(n,n),this.adaptiveLuminancePass.mipLevel1x1=t}},{key:"adaptive",get:function(){return this.defines.has("ADAPTIVE")},set:function(e){this.mode=e?Ut.REINHARD2_ADAPTIVE:Ut.REINHARD2}},{key:"adaptationRate",get:function(){return this.adaptiveLuminancePass.adaptationRate},set:function(e){this.adaptiveLuminancePass.adaptationRate=e}},{key:"distinction",get:function(){return console.warn(this.name,"The distinction field has been removed."),1},set:function(e){console.warn(this.name,"The distinction field has been removed.")}},{key:"update",value:function(e,t,n){this.mode===Ut.REINHARD2_ADAPTIVE&&(this.luminancePass.render(e,t,this.renderTargetLuminance),this.adaptiveLuminancePass.render(e,null,null,n))}},{key:"initialize",value:function(e,t,n){this.adaptiveLuminancePass.initialize(e,t,n)}}]),n}(pe),Ut={REINHARD:0,REINHARD2:1,REINHARD2_ADAPTIVE:2,OPTIMIZED_CINEON:3,ACES_FILMIC:4},Lt="uniform float offset;\r\nuniform float darkness;\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n\r\n\tconst vec2 center = vec2(0.5);\r\n\tvec3 color = inputColor.rgb;\r\n\r\n\t#ifdef ESKIL\r\n\r\n\t\tvec2 coord = (uv - center) * vec2(offset);\r\n\t\tcolor = mix(color, vec3(1.0 - darkness), dot(coord, coord));\r\n\r\n\t#else\r\n\r\n\t\tfloat d = distance(uv, center);\r\n\t\tcolor *= smoothstep(0.8, offset * 0.799, d * (darkness + offset));\r\n\r\n\t#endif\r\n\r\n\toutputColor = vec4(color, inputColor.a);\r\n\r\n}\r\n",Ot=function(e){(0,s.Z)(n,e);var t=g(n);function n(){var e,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(0,c.Z)(this,n);var i=Object.assign({blendFunction:ge.NORMAL,eskil:!1,offset:.5,darkness:.5},r);return(e=t.call(this,"VignetteEffect",Lt,{blendFunction:i.blendFunction,uniforms:new Map([["offset",new d.Uniform(i.offset)],["darkness",new d.Uniform(i.darkness)]])})).eskil=i.eskil,e}return(0,f.Z)(n,[{key:"eskil",get:function(){return this.defines.has("ESKIL")},set:function(e){this.eskil!==e&&(e?this.defines.set("ESKIL","1"):this.defines.delete("ESKIL"),this.setChanged())}}]),n}(pe);new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1]),new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1]),new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1]),new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1]),new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1]),new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1]);var Gt=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;(0,c.Z)(this,e),this.x=t,this.y=n}return(0,f.Z)(e,[{key:"set",value:function(e,t){return this.x=e,this.y=t,this}},{key:"equals",value:function(e){return this===e||this.x===e.x&&this.y===e.y}}]),e}(),Nt=(0,f.Z)((function e(){(0,c.Z)(this,e),this.min=new Gt,this.max=new Gt}));new Nt,new Nt,new Float32Array([0,-.25,.25,-.125,.125,-.375,.375]),new Float32Array([0,0]),new Float32Array([.25,-.25]),new Float32Array([-.25,.25]),new Float32Array([.125,-.125]),new Float32Array([-.125,.125]),new Uint8Array([0,0]),new Uint8Array([3,0]),new Uint8Array([0,3]),new Uint8Array([3,3]),new Uint8Array([1,0]),new Uint8Array([4,0]),new Uint8Array([1,3]),new Uint8Array([4,3]),new Uint8Array([0,1]),new Uint8Array([3,1]),new Uint8Array([0,4]),new Uint8Array([3,4]),new Uint8Array([1,1]),new Uint8Array([4,1]),new Uint8Array([1,4]),new Uint8Array([4,4]),new Uint8Array([0,0]),new Uint8Array([1,0]),new Uint8Array([0,2]),new Uint8Array([1,2]),new Uint8Array([2,0]),new Uint8Array([3,0]),new Uint8Array([2,2]),new Uint8Array([3,2]),new Uint8Array([0,1]),new Uint8Array([1,1]),new Uint8Array([0,3]),new Uint8Array([1,3]),new Uint8Array([2,1]),new Uint8Array([3,1]),new Uint8Array([2,3]),new Uint8Array([3,3]);new Map([[zt([0,0,0,0]),[0,0,0,0]],[zt([0,0,0,1]),[0,0,0,1]],[zt([0,0,1,0]),[0,0,1,0]],[zt([0,0,1,1]),[0,0,1,1]],[zt([0,1,0,0]),[0,1,0,0]],[zt([0,1,0,1]),[0,1,0,1]],[zt([0,1,1,0]),[0,1,1,0]],[zt([0,1,1,1]),[0,1,1,1]],[zt([1,0,0,0]),[1,0,0,0]],[zt([1,0,0,1]),[1,0,0,1]],[zt([1,0,1,0]),[1,0,1,0]],[zt([1,0,1,1]),[1,0,1,1]],[zt([1,1,0,0]),[1,1,0,0]],[zt([1,1,0,1]),[1,1,0,1]],[zt([1,1,1,0]),[1,1,1,0]],[zt([1,1,1,1]),[1,1,1,1]]]);function Ht(e,t,n){return e+(t-e)*n}function zt(e){var t=Ht(e[0],e[1],.75),n=Ht(e[2],e[3],.75);return Ht(t,n,.875)}d.Loader,d.Loader;var Qt='(()=>{function X(s,a,y){let o=document.createElementNS("http://www.w3.org/1999/xhtml","canvas"),t=o.getContext("2d");if(o.width=s,o.height=a,y instanceof Image)t.drawImage(y,0,0);else{let r=t.createImageData(s,a);r.data.set(y),t.putImageData(r,0,0)}return o}var m=class{constructor(a=0,y=0,o=null){this.width=a,this.height=y,this.data=o}toCanvas(){return typeof document=="undefined"?null:X(this.width,this.height,this.data)}static from(a){let{width:y,height:o}=a,t;if(a instanceof Image){let r=X(y,o,a);r!==null&&(t=r.getContext("2d").getImageData(0,0,y,o).data)}else t=a.data;return new m(y,o,t)}};var k=class{constructor(a=0,y=0){this.x=a,this.y=y}set(a,y){return this.x=a,this.y=y,this}equals(a){return this===a||this.x===a.x&&this.y===a.y}},E=class{constructor(){this.min=new k,this.max=new k}},u=new E,I=new E,M=16,q=20,D=30,Z=32,L=new Float32Array([0,-.25,.25,-.125,.125,-.375,.375]),_=[new Float32Array([0,0]),new Float32Array([.25,-.25]),new Float32Array([-.25,.25]),new Float32Array([.125,-.125]),new Float32Array([-.125,.125])],j=[new Uint8Array([0,0]),new Uint8Array([3,0]),new Uint8Array([0,3]),new Uint8Array([3,3]),new Uint8Array([1,0]),new Uint8Array([4,0]),new Uint8Array([1,3]),new Uint8Array([4,3]),new Uint8Array([0,1]),new Uint8Array([3,1]),new Uint8Array([0,4]),new Uint8Array([3,4]),new Uint8Array([1,1]),new Uint8Array([4,1]),new Uint8Array([1,4]),new Uint8Array([4,4])],W=[new Uint8Array([0,0]),new Uint8Array([1,0]),new Uint8Array([0,2]),new Uint8Array([1,2]),new Uint8Array([2,0]),new Uint8Array([3,0]),new Uint8Array([2,2]),new Uint8Array([3,2]),new Uint8Array([0,1]),new Uint8Array([1,1]),new Uint8Array([0,3]),new Uint8Array([1,3]),new Uint8Array([2,1]),new Uint8Array([3,1]),new Uint8Array([2,3]),new Uint8Array([3,3])];function S(s,a,y){return s+(a-s)*y}function z(s){return Math.min(Math.max(s,0),1)}function Y(s,a){let y=a.min,o=a.max,t=Math.sqrt(y.x*2)*.5,r=Math.sqrt(y.y*2)*.5,c=Math.sqrt(o.x*2)*.5,i=Math.sqrt(o.y*2)*.5,e=z(s/Z);return y.set(S(t,y.x,e),S(r,y.y,e)),o.set(S(c,o.x,e),S(i,o.y,e)),a}function d(s,a,y,o){let t=a.x-s.x,r=a.y-s.y,c=y,i=y+1,e=s.y+r*(c-s.x)/t,n=s.y+r*(i-s.x)/t,h,w,x,b;return c>=s.x&&c<a.x||i>s.x&&i<=a.x?Math.sign(e)===Math.sign(n)||Math.abs(e)<1e-4||Math.abs(n)<1e-4?(h=(e+n)/2,h<0?o.set(Math.abs(h),0):o.set(0,Math.abs(h))):(b=-s.y*t/r+s.x,w=b>s.x?e*(b-Math.trunc(b))/2:0,x=b<a.x?n*(1-(b-Math.trunc(b)))/2:0,h=Math.abs(w)>Math.abs(x)?w:-x,h<0?o.set(Math.abs(w),Math.abs(x)):o.set(Math.abs(x),Math.abs(w))):o.set(0,0),o}function B(s,a,y,o,t){let r=u.min,c=u.max,i=I.min,e=I.max,n=I,h=.5+o,w=.5+o-1,x=a+y+1;switch(s){case 0:{t.set(0,0);break}case 1:{a<=y?d(r.set(0,w),c.set(x/2,0),a,t):t.set(0,0);break}case 2:{a>=y?d(r.set(x/2,0),c.set(x,w),a,t):t.set(0,0);break}case 3:{d(r.set(0,w),c.set(x/2,0),a,i),d(r.set(x/2,0),c.set(x,w),a,e),Y(x,n),t.set(i.x+e.x,i.y+e.y);break}case 4:{a<=y?d(r.set(0,h),c.set(x/2,0),a,t):t.set(0,0);break}case 5:{t.set(0,0);break}case 6:{Math.abs(o)>0?(d(r.set(0,h),c.set(x,w),a,i),d(r.set(0,h),c.set(x/2,0),a,e),d(r.set(x/2,0),c.set(x,w),a,t),e.set(e.x+t.x,e.y+t.y),t.set((i.x+e.x)/2,(i.y+e.y)/2)):d(r.set(0,h),c.set(x,w),a,t);break}case 7:{d(r.set(0,h),c.set(x,w),a,t);break}case 8:{a>=y?d(r.set(x/2,0),c.set(x,h),a,t):t.set(0,0);break}case 9:{Math.abs(o)>0?(d(r.set(0,w),c.set(x,h),a,i),d(r.set(0,w),c.set(x/2,0),a,e),d(r.set(x/2,0),c.set(x,h),a,t),e.set(e.x+t.x,e.y+t.y),t.set((i.x+e.x)/2,(i.y+e.y)/2)):d(r.set(0,w),c.set(x,h),a,t);break}case 10:{t.set(0,0);break}case 11:{d(r.set(0,w),c.set(x,h),a,t);break}case 12:{d(r.set(0,h),c.set(x/2,0),a,i),d(r.set(x/2,0),c.set(x,h),a,e),Y(x,n),t.set(i.x+e.x,i.y+e.y);break}case 13:{d(r.set(0,w),c.set(x,h),a,t);break}case 14:{d(r.set(0,h),c.set(x,w),a,t);break}case 15:{t.set(0,0);break}}return t}function J(s,a,y,o){let t=s.equals(a);if(!t){let r=(s.x+a.x)/2,c=(s.y+a.y)/2,i=a.y-s.y,e=s.x-a.x;t=i*(y-r)+e*(o-c)>0}return t}function G(s,a,y,o){let t,r,c,i,e;for(t=0,c=0;c<D;++c)for(r=0;r<D;++r)i=r/(D-1),e=c/(D-1),J(s,a,y+i,o+e)&&++t;return t/(D*D)}function A(s,a,y,o,t,r){let c=W[s],i=c[0],e=c[1];return i>0&&(a.x+=t[0],a.y+=t[1]),e>0&&(y.x+=t[0],y.y+=t[1]),r.set(1-G(a,y,1+o,0+o),G(a,y,1+o,1+o))}function K(s,a,y,o,t){let r=u.min,c=u.max,i=I.min,e=I.max,n=a+y+1;switch(s){case 0:{A(s,r.set(1,1),c.set(1+n,1+n),a,o,i),A(s,r.set(1,0),c.set(1+n,0+n),a,o,e),t.set((i.x+e.x)/2,(i.y+e.y)/2);break}case 1:{A(s,r.set(1,0),c.set(0+n,0+n),a,o,i),A(s,r.set(1,0),c.set(1+n,0+n),a,o,e),t.set((i.x+e.x)/2,(i.y+e.y)/2);break}case 2:{A(s,r.set(0,0),c.set(1+n,0+n),a,o,i),A(s,r.set(1,0),c.set(1+n,0+n),a,o,e),t.set((i.x+e.x)/2,(i.y+e.y)/2);break}case 3:{A(s,r.set(1,0),c.set(1+n,0+n),a,o,t);break}case 4:{A(s,r.set(1,1),c.set(0+n,0+n),a,o,i),A(s,r.set(1,1),c.set(1+n,0+n),a,o,e),t.set((i.x+e.x)/2,(i.y+e.y)/2);break}case 5:{A(s,r.set(1,1),c.set(0+n,0+n),a,o,i),A(s,r.set(1,0),c.set(1+n,0+n),a,o,e),t.set((i.x+e.x)/2,(i.y+e.y)/2);break}case 6:{A(s,r.set(1,1),c.set(1+n,0+n),a,o,t);break}case 7:{A(s,r.set(1,1),c.set(1+n,0+n),a,o,i),A(s,r.set(1,0),c.set(1+n,0+n),a,o,e),t.set((i.x+e.x)/2,(i.y+e.y)/2);break}case 8:{A(s,r.set(0,0),c.set(1+n,1+n),a,o,i),A(s,r.set(1,0),c.set(1+n,1+n),a,o,e),t.set((i.x+e.x)/2,(i.y+e.y)/2);break}case 9:{A(s,r.set(1,0),c.set(1+n,1+n),a,o,t);break}case 10:{A(s,r.set(0,0),c.set(1+n,1+n),a,o,i),A(s,r.set(1,0),c.set(1+n,0+n),a,o,e),t.set((i.x+e.x)/2,(i.y+e.y)/2);break}case 11:{A(s,r.set(1,0),c.set(1+n,1+n),a,o,i),A(s,r.set(1,0),c.set(1+n,0+n),a,o,e),t.set((i.x+e.x)/2,(i.y+e.y)/2);break}case 12:{A(s,r.set(1,1),c.set(1+n,1+n),a,o,t);break}case 13:{A(s,r.set(1,1),c.set(1+n,1+n),a,o,i),A(s,r.set(1,0),c.set(1+n,1+n),a,o,e),t.set((i.x+e.x)/2,(i.y+e.y)/2);break}case 14:{A(s,r.set(1,1),c.set(1+n,1+n),a,o,i),A(s,r.set(1,1),c.set(1+n,0+n),a,o,e),t.set((i.x+e.x)/2,(i.y+e.y)/2);break}case 15:{A(s,r.set(1,1),c.set(1+n,1+n),a,o,i),A(s,r.set(1,0),c.set(1+n,0+n),a,o,e),t.set((i.x+e.x)/2,(i.y+e.y)/2);break}}return t}function H(s,a,y){let o=new k,t,r,c,i,e,n,h,w;for(t=0,r=s.length;t<r;++t)for(n=s[t],h=n.data,w=n.width,i=0;i<w;++i)for(c=0;c<w;++c)y?B(t,c,i,a,o):K(t,c,i,a,o),e=(i*w+c)*2,h[e]=o.x*255,h[e+1]=o.y*255}function T(s,a,y,o,t,r){let c=new k,i=r.data,e=r.width,n,h,w,x,b,U,C,F,P,l;for(n=0,h=a.length;n<h;++n)for(C=y[n],F=a[n],P=F.data,l=F.width,x=0;x<o;++x)for(w=0;w<o;++w)c.set(C[0]*o+s.x+w,C[1]*o+s.y+x),b=(c.y*e+c.x)*4,U=t?(x*x*l+w*w)*2:(x*l+w)*2,i[b]=P[U],i[b+1]=P[U+1],i[b+2]=0,i[b+3]=255}var v=class{static generate(){let a=2*5*M,y=L.length*5*M,o=new Uint8ClampedArray(a*y*4),t=new m(a,y,o),r=Math.pow(M-1,2)+1,c=q,i=[],e=[],n=new k,h,w;for(h=0;h<16;++h)i.push(new m(r,r,new Uint8ClampedArray(r*r*2),2)),e.push(new m(c,c,new Uint8ClampedArray(c*c*2),2));for(h=0,w=L.length;h<w;++h)H(i,L[h],!0),n.set(0,5*M*h),T(n,i,j,M,!0,t);for(h=0,w=_.length;h<w;++h)H(e,_[h],!1),n.set(5*M,4*q*h),T(n,e,W,q,!1,t);return t}};var O=new Map([[g([0,0,0,0]),[0,0,0,0]],[g([0,0,0,1]),[0,0,0,1]],[g([0,0,1,0]),[0,0,1,0]],[g([0,0,1,1]),[0,0,1,1]],[g([0,1,0,0]),[0,1,0,0]],[g([0,1,0,1]),[0,1,0,1]],[g([0,1,1,0]),[0,1,1,0]],[g([0,1,1,1]),[0,1,1,1]],[g([1,0,0,0]),[1,0,0,0]],[g([1,0,0,1]),[1,0,0,1]],[g([1,0,1,0]),[1,0,1,0]],[g([1,0,1,1]),[1,0,1,1]],[g([1,1,0,0]),[1,1,0,0]],[g([1,1,0,1]),[1,1,0,1]],[g([1,1,1,0]),[1,1,1,0]],[g([1,1,1,1]),[1,1,1,1]]]);function N(s,a,y){return s+(a-s)*y}function g(s){let a=N(s[0],s[1],1-.25),y=N(s[2],s[3],1-.25);return N(a,y,1-.125)}function Q(s,a){let y=0;return a[3]===1&&(y+=1),y===1&&a[2]===1&&s[1]!==1&&s[3]!==1&&(y+=1),y}function V(s,a){let y=0;return a[3]===1&&s[1]!==1&&s[3]!==1&&(y+=1),y===1&&a[2]===1&&s[0]!==1&&s[2]!==1&&(y+=1),y}var R=class{static generate(){let a=66,y=33,o=a/2,t=64,r=16,c=new Uint8ClampedArray(a*y),i=new Uint8ClampedArray(t*r*4),e,n,h,w,x,b,U;for(n=0;n<y;++n)for(e=0;e<a;++e)h=.03125*e,w=.03125*n,O.has(h)&&O.has(w)&&(b=O.get(h),U=O.get(w),x=n*a+e,c[x]=127*Q(b,U),c[x+o]=127*V(b,U));for(x=0,n=y-r;n<y;++n)for(e=0;e<t;++e,x+=4)i[x]=c[n*a+e],i[x+3]=255;return new m(t,r,i)}};self.addEventListener("message",s=>{let a=v.generate(),y=R.generate();postMessage({areaImageData:a,searchImageData:y},[a.data.buffer,y.data.buffer]),close()});})();\n';function Zt(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=URL.createObjectURL(new Blob([Qt],{type:"text/javascript"})),n=new Worker(t);return new Promise((function(r,i){n.addEventListener("error",(function(e){return i(e.error)})),n.addEventListener("message",(function(n){var i=lt.from(n.data.searchImageData),a=lt.from(n.data.areaImageData),o=[i.toCanvas().toDataURL(),a.toCanvas().toDataURL()];e||void 0===window.localStorage||(localStorage.setItem("smaa-search",o[0]),localStorage.setItem("smaa-area",o[1])),URL.revokeObjectURL(t),r(o)})),n.postMessage(null)}))}var Vt=function(e){(0,s.Z)(n,e);var t=g(n);function n(e){var r;return(0,c.Z)(this,n),(r=t.call(this,e)).disableCache=!1,r}return(0,f.Z)(n,[{key:"load",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){},n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){};4===arguments.length?(t=arguments[1],n=arguments[3]):3!==arguments.length&&"function"==typeof arguments[0]||(t=arguments[1],n=function(){});var r=this.manager,i=new d.LoadingManager;return r.itemStart("smaa-search"),r.itemStart("smaa-area"),i.itemStart("smaa-search"),i.itemStart("smaa-area"),new Promise((function(a,o){var s=e.disableCache||void 0===window.localStorage?[null,null]:[localStorage.getItem("smaa-search"),localStorage.getItem("smaa-area")];(null!==s[0]&&null!==s[1]?Promise.resolve(s):Zt(e.disableCache)).then((function(e){var n=[new Image,new Image];i.onLoad=function(){t(n),a(n)},n[0].addEventListener("load",(function(){r.itemEnd("smaa-search"),i.itemEnd("smaa-search")})),n[1].addEventListener("load",(function(){r.itemEnd("smaa-area"),i.itemEnd("smaa-area")})),n[0].src=e[0],n[1].src=e[1]})).catch((function(e){r.itemError("smaa-search"),r.itemError("smaa-area"),n(e),o(e)}))}))}}]),n}(d.Loader)}}]);
//# sourceMappingURL=4bdf9057-5d9210c69d49935cb678.js.map